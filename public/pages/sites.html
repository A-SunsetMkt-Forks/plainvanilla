<!doctype html>
<html lang="en">
<head>
    <title>Plain Vanilla - Sites</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
    <link rel="icon" href="../favicon.ico">
    <link rel="stylesheet" href="../index.css">
</head>
<body>
    <noscript><strong>Please enable JavaScript to view this page correctly.</strong></noscript>
    <script type="module" src="../index.js"></script>
    <header>
        <h1>Sites</h1>
        <nav>
            <ul>
                <li><a href="../index.html">Introduction</a></li>
                <li><a href="components.html">Components</a></li>
                <li><a href="styling.html">Styling</a></li>
                <li>Sites</li>
                <li><a href="applications.html">Applications</a></li>
            </ul>
        </nav>
    </header>
    <main>
        <section>
            <h2>Pages</h2>
            <p>For content-driven websites with low interactivity a multi-page approach is best suited.</p>
            <p>Abandoning the use of frameworks means writing out those HTML pages from scratch. For this it is important to understand what a good minimal HTML page should look like.</p>
            <x-code-viewer src="./examples/sites/page/example.html"></x-code-viewer>
            <p>An explanation of each element:</p>
            <dl>
                <dt><code>&lt;!doctype html&gt;</code></dt>
                <dd>The doctype is required to have the HTML parsed as HTML5 instead of an older version.</dd>
                <dt><code>&lt;html lang="en"&gt;</code></dt>
                <dd>The lang attribute is recommended to make sure browsers don't misdetect the language used in the page.</dd>
                <dt><code>&lt;head&gt;&lt;title&gt;</code></dt>
                <dd>The title will be used for the browser tab and when bookmarking, making it effectively non-optional.</dd>
                <dt><code>&lt;head&gt;&lt;meta name="viewport"&gt;</code></dt>
                <dd>The viewport meta is necessary to have mobile-friendly layout.</dd>
                <dt><code>&lt;head&gt;&lt;link rel="stylesheet" href="index.css"&gt;</code></dt>
                <dd>By convention the stylesheet is loaded from <code>&lt;head&gt;</code> in a blocking way to ensure the page's markup does not have a flash of unstyled content.</dd>
                <dt><code>&lt;body&gt;&lt;noscript&gt;</code></dt>
                <dd>Because web components don't work without JavaScript it is good practice to include a noscript warning to users that have JavaScript disabled. This warning only needs to be on pages with web components. If you don't want to show anything except the warning, see the template pattern below.</dd>
                <dt><code>&lt;body&gt;&lt;header/main/footer&lt;</code></dt>
                <dd>The page's markup should be organized using <a href="https://developer.mozilla.org/en-US/blog/aria-accessibility-html-landmark-roles/">HTML landmarks</a>. Landmarks when used properly help organize the page into logical blocks and make the page's structure accessible. Because they are standards-based, compatibility with present and future accessibility products is more likely.</dd>
                <dt><code>&lt;body&gt;&lt;script type="module" src="index.js"&gt;</code></dt>
                <dd>The main JavaScript file is at the end, and will bootstrap the web components as explained on the components page.</dd>
            </dl>
            <p>
                Pages that should only show their contents if JavaScript is enabled can use this template pattern:
            </p>
            <x-code-viewer src="./examples/sites/page/example2.html"></x-code-viewer>
            <x-code-viewer src="./examples/sites/page/index.js"></x-code-viewer>
            
            <h3>Favicons</h3>

            <p>
                There is one thing that you will probably want to add to the HTML that is not standards-based and that is a reference to a favicon:
            </p>
            <ul>
                <li>To keep it really simple, put a <code>favicon.ico</code> in the root path of the site and link to it from your HTML: <code>&lt;link rel="icon" href="favicon.ico"&gt;</code></li>
                <li>Consider <a href="https://medium.com/swlh/are-you-using-svg-favicons-yet-a-guide-for-modern-browsers-836a6aace3df">SVG favicons</a>, but be aware that Safari does not support them. <a href="https://css-tricks.com/svg-favicons-in-action/">Embed dark mode</a> in the favicon SVG itself or use a generator like <a href="https://realfavicongenerator.net/">RealFaviconGenerator</a> for more convience.</li>
                <li>Be aware that because favicons are not based on web standards it is cumbersome to implement the <a href="https://dev.to/masakudamatsu/favicon-nightmare-how-to-maintain-sanity-3al7">de facto standards</a> fully.</li>
            </ul>
        </section>
        <section>
            <h2>Project</h2>
            <h3>Layout</h3>
            <p>
                A suggested project layout for a vanilla multi-page website:
            </p>
            <dl>
                <dt>/</dt>
                <dd>The project root contains the files that will not be published, such as <code>README.md</code>, <code>LICENSE</code> or <code>.gitignore</code>.</dd>
                <dt>/public</dt>
                <dd>The public folder is published as-is, without build steps. It is the whole website.</dd>
                <dt>/public/index.html</dt>
                <dd>The main landing page of the website, not particularly different from the other pages, except for its path.</dd>
                <dt>/public/index.[js/css]</dt>
                <dd>
                    The main stylesheet and javascript. These contain the shared styles and code for all pages.
                    <code>index.js</code> loads and registers the web components used on all pages.
                    By sharing these across multiple HTML pages unnecessary duplication and inconsistencies between pages can be avoided.
                </dd>
                <dt>/public/pages/<em>[name]</em>.html</dt>
                <dd>
                    All of the site's other pages, each including the same <code>index.js</code> and <code>index.css</code>,
                    and ofcourse containing the content directly as markup in the HTML, leveraging the web components.
                </dd>
                <dt>/public/components/<em>[name]</em>/</dt>
                <dd>
                    One folder per web component, containing a <code>[name].js</code> and <code>[name].css</code> file.
                    The <code>.js</code> file is imported into the <code>index.js</code> file to register the web component.
                    The <code>.css</code> file is imported into the global <code>index.css</code> or in the shadow DOM, as explained on the styling page.
                </dd>
                <dt>/public/lib/</dt>
                <dd>For all external libraries used as dependencies. See below for how to add and use these dependencies.</dd>
                <dt>/public/styles/</dt>
                <dd>The global styles referenced from <code>index.css</code>, as explained on the styling page.</dd>
            </dl>

            <h3>Routing</h3>
            <p>
                The old-school routing approach of standard HTML pages and <code>&lt;a&gt;</code> tags to link them together has the advantages of being easily indexed by search engines
                and fully supporting browser history and bookmarking functionality out of the box. ðŸ˜‰
            </p>
        </section>
        <section>
            <h2>Example</h2>
            <!-- TODO: update link -->
            <p>This website is the example. Check out the <a href="https://github.com/jsebrech/">project on GitHub</a>.</p>
        </section>
        <section>
            <h2>Dependencies</h2>
            <p>At some point you may want to pull in third-party libraries. Without npm and a bundler this is still possible.</p>
            <h3>Unpkg</h3>
            <p>
                To use libraries without a bundler they need to be prebuilt in either ESM or UMD format.
                These libraries can be obtained from unpkg.com:
            </p>
            <ol>
                <li>Browse to <code>unpkg.com/[library]/</code> (trailing slash matters), for example <a href="https://unpkg.com/microlight/" target="_blank">unpkg.com/microlight/</a></li>
                <li>Look for and download the library js file, which may be in a subfolder, like <code>dist</code>, <code>esm</code> or <code>umd</code></li>
                <li>Place the library file in the <code>lib/</code> folder</li>
            </ol>
            <p>Alternatively, the library may be loaded directly from CDN.</p>

            <h3>UMD</h3>
            <p>
                The <a href="https://jameshfisher.com/2020/10/04/what-are-umd-modules/">UMD module format</a> is an older format for libraries loaded from script tag,
                and it is the most widely supported, especially among older libraries.
                It can be recognized by having <code>typeof define === 'function' && define.amd</code> somewhere in the library JS.
            </p>
            <p>To include it in your project:</p>
            <ol>
                <li>Include it in a script tag: <code>&lt;script src="lib/microlight.js"&gt;&lt;/script&gt;</code></li>
                <li>Obtain it off the window: <code>const { microlight } = window;</code></li>
            </ol>

            <h3>ESM</h3>
            <p>
                The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">ESM module format</a> (also known as JavaScript modules) is the format specified by the ECMAScript standard, and newer or well-behaved libraries will typically provide an ESM build.
                It can be recognized by the use of the <code>export</code> keyword.
            </p>
            <p>To include it in your project:</p>
            <ul>
                <li>Load it from CDN:<br><code>import('https://unpkg.com/web-vitals@4.2.2/dist/web-vitals.js').then((webVitals) => ...)</code></li>
                <li>Or load it from a local copy:<br><code>import webVitals from 'lib/web-vitals.js'</code></li>
            </ul>

            <h3>imports.js</h3>
            <p>
                To neatly organize libraries, it is best to load and export them from an <code>imports.js</code> file.
                For example, here is a page that uses a UMD build of <a href="https://day.js.org/">Day.js</a> and an ESM build of <a href="https://github.com/GoogleChrome/web-vitals">web-vitals</a>:
            </p>
            <iframe src="./examples/sites/imports/index.html" height="100"></iframe>
            <p>The text is rendered by the <code>&lt;x-metrics&gt;</code> component:</p>
            <x-code-viewer src="./examples/sites/imports/components/metrics.js" name="components/metrics.js"></x-code-viewer>
            <p>In the <code>/lib</code> folder we find these files:</p>
            <ul>
                <li>web-vitals.js - the ESM build of web-vitals</li>
                <li>dayjs/</li>
                <ul>
                    <li>dayjs.min.js - the UMD build of Day.js</li>
                    <li>relativeTime.js - the UMD build of this Day.js plugin</li>
                </ul>
                <li>imports.js</li>
            </ul>
            <p>Digging deeper into this last file we see how it bundles loading of third-party dependencies:</p>
            <x-code-viewer src="./examples/sites/imports/lib/imports.js" name="lib/imports.js"></x-code-viewer>
            <p>
                It imports the ESM library directly, but it pulls the UMD libraries off the <code>Window</code> object.
                These are loaded in the HTML:
            </p>
            <x-code-viewer src="./examples/sites/imports/index.html"></x-code-viewer>
            <p>Regrettably not all libraries have a UMD or ESM build, but more and more do.</p>
        </section>
        <section>
            <h2>Deploying</h2>
            TODO: write deploying section
        </section>
        <section>
            <h2>Up next</h2>
            Learn how to build <a href="applications.html">single-page applications</a> using vanilla techniques.
        </section>
    </main>
</body>
</html>