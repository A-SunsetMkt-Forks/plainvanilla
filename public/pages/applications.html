<!doctype html>
<html lang="en">
<head>
    <title>Plain Vanilla - Applications</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
    <meta name="description" content="An explainer for developing single-page applications using only vanilla techniques.">
    <link rel="icon" href="../favicon.ico">
    <link rel="apple-touch-icon" href="../apple-touch-icon.png">
    <link rel="stylesheet" href="../index.css">
</head>
<body>
    <noscript><strong>Please enable JavaScript to view this page correctly.</strong></noscript>
    <script type="module" src="../index.js"></script>
    <header>
        <h1>Plain Vanilla Applications</h1>
        <nav>
            <ul>
                <li><a href="../index.html">Introduction</a></li>
                <li><a href="components.html">Components</a></li>
                <li><a href="styling.html">Styling</a></li>
                <li><a href="sites.html">Sites</a></li>
                <li>Applications</li>
            </ul>
        </nav>
    </header>
    <main>
        <section id="project">
            <a href="#project" class="section-anchor">#</a>
            <h2>Project</h2>
            <p>When richer interactivity and dynamic state are needed, a single-page application is often a better fit than a multi-page website.</p>

            <p>The suggested project layout for single-page applications is the same as for multi-page sites, except:</p>
            <dl>
                <dt>/public/pages</dt>
                <dd>As there is only <code>index.html</code> there is no need for the pages folder.</dd>
                <dt>/public/app</dt>
                <dd>All of the views and routes for the application are in this folder, each implemented as a web component, and registered in <code>index.js</code>.</dd>
                <dt>/public/app/App.js</dt>
                <dd>As in the major frameworks, the application is bootstrapped from an App component. See the example below.</dd>
            </dl>
        </section>
        <section id="routing">
            <a href="#routing" class="section-anchor">#</a>
            <h2>Routing</h2>

            <p>Without the assistance of a server to do routing, the only option is hash-based routing:</p>
            <ul>
                <li>The current route is in <code>window.location.hash</code>, e.g. <code>#/about</code>.</li>
                <li>The route's changes are detected by listening to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/hashchange_event">Window hashchange event</a>.</li>
                <li>Each web component is shown or hidden based on the active route.</li>
            </ul>
            <p>This behavior can be encapsulated in a routing web component:</p>
            <x-code-viewer src="./examples/applications/single-page/components/route/route.js" name="components/route/route.js"></x-code-viewer>

            <p>An example single-page vanilla application that uses this routing component:</p>

            <iframe src="./examples/applications/single-page/index.html" title="single-page application" height="400"></iframe>

            <x-tab-panel>
                <x-tab title="index.html" active>
                    <x-code-viewer src="./examples/applications/single-page/index.html" name=""></x-code-viewer>
                </x-tab>
                <x-tab title="index.css">
                    <x-code-viewer src="./examples/applications/single-page/index.css" name=""></x-code-viewer>
                </x-tab>
                <x-tab title="index.js">
                    <x-code-viewer src="./examples/applications/single-page/index.js" name=""></x-code-viewer>
                </x-tab>
                <x-tab title="App.js">
                    <x-code-viewer src="./examples/applications/single-page/app/App.js" name="app/App.js"></x-code-viewer>
                </x-tab>
                <x-tab title="route.js">
                    <x-code-viewer src="./examples/applications/single-page/components/route/route.js" name="components/route/route.js"></x-code-viewer>
                </x-tab>
            </x-tab-panel>

            <p>It makes use of the template pattern to avoid showing a broken application if scripting is disabled.</p>

            <p>Adding additional route components to the <code>/app</code> folder is left as an exercise for the reader.</p>

            <aside>
                <h4>About Search Engines</h4>
                <p>
                    The hash-based routing approach is effectively invisible to search engines. Only the initial route will be indexed.
                    For this reason this approach is not suited to sites that have SEO concerns.
                    Every route that must be discoverable through a search engine should use the multi-file approach explained on the Sites page.
                </p>
            </aside>

        </section>
        <section id="managing-state">
            <a href="#managing-state" class="section-anchor">#</a>
            <h2>Managing state</h2>

            <h3>Lifting state up</h3>
            <p>
                Generally speaking, the <a href="https://react.dev/learn/choosing-the-state-structure">state management principles</a> laid out in the React documentation are sound and should be followed even for vanilla web development.
                Here they are once again:
            </p>
            <ol>
                <li><strong>Group related state.</strong> If you always update two or more state variables at the same time, consider merging them into a single state variable.</li>
                <li><strong>Avoid contradictions in state.</strong> When the state is structured in a way that several pieces of state may contradict and “disagree” with each other, you leave room for mistakes. Try to avoid this.</li>
                <li><strong>Avoid redundant state.</strong> If you can calculate some information from the component's attributes or properties during rendering, you should not put that information into that component's state.</li>
                <li><strong>Avoid duplication in state.</strong> When the same data is duplicated between multiple state variables, or within nested objects, it is difficult to keep them in sync. Reduce duplication when you can.</li>
                <li><strong>Avoid deeply nested state.</strong> Deeply hierarchical state is not very convenient to update. When possible, prefer to structure state in a flat way.</li>
            </ol>

            <p>React's <a href="https://react.dev/learn/sharing-state-between-components">lifting state up tutorial</a> explains very well how to share state between components. The final example shows how a central non-duplicated <code>activeIndex</code> state can track which panel is active:</p>
            <x-code-viewer src="./examples/applications/lifting-state-up/react/App.js"></x-code-viewer>

            <p>Here is that example adapted to vanilla web components:</p>

            <iframe src="./examples/applications/lifting-state-up/index.html" title="lifting state up example" height="400"></iframe>

            <x-tab-panel>
                <x-tab title="index.html" active>
                    <x-code-viewer src="./examples/applications/lifting-state-up/index.html" name=""></x-code-viewer>
                </x-tab>
                <x-tab title="index.css">
                    <x-code-viewer src="./examples/applications/lifting-state-up/index.css" name=""></x-code-viewer>
                </x-tab>
                <x-tab title="index.js">
                    <x-code-viewer src="./examples/applications/lifting-state-up/index.js" name=""></x-code-viewer>
                </x-tab>
                <x-tab title="accordion.js">
                    <x-code-viewer src="./examples/applications/lifting-state-up/components/accordion.js" name="components/accordion.js"></x-code-viewer>
                </x-tab>
                <x-tab title="panel.js">
                    <x-code-viewer src="./examples/applications/lifting-state-up/components/panel.js" name="components/panel.js"></x-code-viewer>
                </x-tab>
            </x-tab-panel>

            <p>What to pay attention to:</p>
            <ul>
                <li>
                    State is kept as properties or attributes on a web component, as shown here with the accordion's <code>activeIndex</code> property.
                </li>
                <li>
                    The property setter for <code>activeIndex</code> explicitly calls the <code>update()</code> method to bring the DOM in sync with the property's state.
                </li>
                <li>
                    The <code>update()</code> method on the <code>&lt;x-panel&gt;</code> component is written in a defensive way, because it may be called from the <code>attributeChangedCallback()</code> method before <code>connectedCallback()</code> sets up the DOM structure.
                </li>
            </ul>

            <aside>
                <h4>Tread lightly</h4>
                <p>
                    In vanilla web development the components become part of the DOM hierarchy, instead of existing outside of the DOM and having changes applied to it automatically by the framework.
                    This means the application's state itself becomes part of the DOM.
                </p>
                <p>
                    Because there is no framework patching the DOM with only the parts that changed, we have to tread lightly and only update the DOM when and where that is needed.
                    Updating too much of the DOM risks losing state or causing performance issues.
                    Each web component in this example renders its fixed DOM structure once in <code>connectedCallback()</code> and then updates the state of those DOM elements in the <code>update()</code> method when something changes.
                </p>
            </aside>

            <h3>Passing data deeply</h3>

            <p>
                While passing state from parent components to child components via attributes or properties works,
                it can quickly become verbose and inconvenient, especially if you have to pass those through many components in the middle.
            </p>
            <p>
                React solves this using the context, as explained on the <a href="https://react.dev/reference/react/useContext">useContext documentation page</a>.
                The first example on that page shows a ThemeContext that keeps track of a theme variable, that can then be fetched anywhere in the hierarchy of components below.
            </p>
            <p>
                A similar approach is possible by having a special "context" web component, whose only job is to keep track of state, provide setters to update that state, and dispatch events when the state changes.
                Here is an adapted version of the context example that uses a theme context to keep track of light or dark theme, toggled by a button.
            </p>

            <iframe src="./examples/applications/passing-data-deeply/index.html" title="passing data deeply example" height="200"></iframe>

            <x-tab-panel>
                <x-tab title="index.html" active>
                    <x-code-viewer src="./examples/applications/passing-data-deeply/index.html" name=""></x-code-viewer>
                </x-tab>
                <x-tab title="index.css">
                    <x-code-viewer src="./examples/applications/passing-data-deeply/index.css" name=""></x-code-viewer>
                </x-tab>
                <x-tab title="index.js">
                    <x-code-viewer src="./examples/applications/passing-data-deeply/index.js" name=""></x-code-viewer>
                </x-tab>
                <x-tab title="theme-context.js">
                    <x-code-viewer src="./examples/applications/passing-data-deeply/components/theme-context.js" name="components/theme-context.js"></x-code-viewer>
                </x-tab>
                <x-tab title="panel.js">
                    <x-code-viewer src="./examples/applications/passing-data-deeply/components/panel.js" name="components/panel.js"></x-code-viewer>
                </x-tab>
                <x-tab title="button.js">
                    <x-code-viewer src="./examples/applications/passing-data-deeply/components/button.js" name="components/button.js"></x-code-viewer>
                </x-tab>
            </x-tab-panel>

            <p>An explanation of salient points:</p>
            <ul>
                <li>
                    The <code>x-theme-context</code> component uses <code>display: contents</code> to avoid impacting the layout.
                    It exists in the DOM hierarchy, but it becomes effectively invisible.
                    The only way it can be noticed is by its shadow root.
                </li>
                <li>
                    Instead of <code>useContext</code> every component obtains the nearest theme context with <code>this.closest('x-theme-context')</code> utilizing the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/closest">Element.closest</a> API.
                    To be notified of theme changes, those components subscribe to the <code>themechange</code> event of the context.
                </li>
                <li>
                    Context components can implement additional methods that provide convenience API's around the context's state,
                    like the <code>toggleTheme()</code> method in this example. 
                </li>
            </ul>
            
            <p>
                This approach can be further extended to implement reducers, by adding them as a method on a context component
                and updating the state through the setters, dispatching the necessary events to update the component hierarchy.
            </p>

            <aside>
                <h4>Challenge</h4>
                <p>To prove your mastery of vanilla web development use the techniques you've learned to port example 5 ("Scaling up with context and a reducer") from React's <a href="https://react.dev/reference/react/useContext">useContext</a> documentation page to vanilla code.
            </aside>
        </section>
        <section>
            <h2>Up next</h2>
            Go build something vanilla!
        </section>
    </main>

    <footer>
        <hr />
        <span class="contact">
            <img src="../lib/akar-icons/github-fill.svg" alt="github" /> <a href="https://github.com/jsebrech/plainvanilla">GitHub</a>
        </span>
        <span class="contact">
            <img src="../lib/akar-icons/envelope.svg" alt="mail" /> <a href="https://sebrechts.net/">Contact</a>
        </span>
    </footer>
</body>
</html>