<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>Plain Vanilla Blog</title>
    <id>https://plainvanillaweb.com/blog/</id>
    <icon>https://plainvanillaweb.com/favicon.ico</icon>
    <logo>https://plainvanillaweb.com/android-chrome-512x512.png</logo>
    <link rel="alternate" href="https://plainvanillaweb.com/blog/"/>
    <link rel="self" href="https://plainvanillaweb.com/blog/feed.xml"/>
    <updated>2024-09-09T12:00:00.000Z</updated>
    <author>
        <name>Joeri Sebrechts</name>
    </author>
    <entry>
        <title><![CDATA[Sweet Suspense]]></title>
        <link rel="alternate" type="text/html" href="https://plainvanillaweb.com/blog/articles/2024-09-09-sweet-suspense/"/>
        <id>https://plainvanillaweb.com/blog/articles/2024-09-09-sweet-suspense/</id>
        <published>2024-09-09T12:00:00.000Z</published>
        <updated>2024-09-09T12:00:00.000Z</updated>
        <summary><![CDATA[React-style lazy loading of web components.]]></summary>
        <media:content url="https://plainvanillaweb.com/blog/articles/2024-09-09-sweet-suspense/image.webp" type="image/webp" medium="image" />
        <author><name><![CDATA[Joeri Sebrechts]]></name></author>
        <content type="html"><![CDATA[
        <p>
            I was reading Addy Osmani and Hassan Djirdeh's book <a href="https://largeapps.dev/">Building Large Scale Web Apps</a>.
            (Which, by the way, I can definitely recommend.) In it they cover all the ways to make a React app sing at scale.
            The chapter on <em>Modularity</em> was especially interesting to me, because JavaScript modules
            are a common approach to modularity in both React and vanilla web code.
        </p>
        <p>
            In that chapter on <em>Modularity</em> there was one particular topic that caught my eye,
            and it was the use of <code>lazy()</code> and <code>Suspense</code>, paired with an <code>ErrorBoundary</code>.
            These are the primitives that React gives us to asynchronously load UI components and their data on-demand while showing a fallback UI,
            and replace the UI with an error message when something goes wrong.
            If you're not familiar, here's a good <a href="https://refine.dev/blog/react-lazy-loading/#catching-loading-errors">overview page</a>.
        </p>
        <p>
            It was at that time that I was visited by the imp of the perverse, which posed to me a simple challenge:
            <em>can you bring React's lazy loading primitives to vanilla web components?</em>
            To be clear, there are <a href="https://css-tricks.com/an-approach-to-lazy-loading-custom-elements/">many</a> 
            <a href="https://github.com/codewithkyle/lazy-loader">ways</a> to 
            <a href="https://www.webcomponents.org/element/st-lazy">load</a> web components 
            <a href="https://lamplightdev.com/blog/2020/03/20/lazy-loading-web-components-with-intersection-observer/">lazily</a>. 
            This is well-trodden territory. What wasn't out there was a straight port of lazy, suspense and error boundary. 
            The idea would not let me go. So here goes nothing.
        </p>

        <h3>Lazy</h3>

        <p>
            The idea and execution of React's lazy is simple. Whenever you want to use a component in your code,
            but you don't want to actually fetch its code yet until it needs to be rendered, wrap it using the <code>lazy()</code> function:<br>
            <code>const MarkdownPreview = lazy(() =&gt; import('./MarkdownPreview.js'));</code><br>
        </p>
        <p>
            React will automatically "suspend" rendering when it first bumps into this lazy component until the component has loaded, and then continue automatically.
        </p>
        <p>
            This works in React because the markup of a component only looks like HTML, 
            but is actually JavaScript in disguise, better known as <em>JSX</em>.
            With web components however, the markup that the component is used in is actually HTML,
            where there is no <code>import()</code> and no calling of functions.
            That means our vanilla <em>lazy</em> cannot be a JavaScript function, but instead it must be an HTML custom element:<br>
            <code>&lt;x-lazy&gt;&lt;x-hello-world&gt;&lt;/x-hello-world&gt;&lt;/x-lazy&gt;</code>
        </p>

        <p>
            The basic setup is simple, when the lazy component is added to the DOM,
            we'll scan for children that have a '-' in the name and therefore are custom elements,
            see if they're not yet defined, and load and define them if so.
            By using <code>display: contents</code> we can avoid having the <code>&lt;x-lazy&gt;</code> impact layout.
        </p>
        <pre><code>customElements.define('x-lazy', class extends HTMLElement {
    connectedCallback() {
        this.style.display = 'contents';
        this.#loadLazy();
    }

    #loadLazy() {
        const elements = 
            [...this.children].filter(_ =&gt; _.localName.includes('-'));
        const unregistered = 
            elements.filter(_ =&gt; !customElements.get(_.localName));
        unregistered.forEach(_ =&gt; this.#loadElement(_));
    }

    #loadElement(element) {
        // TODO: load the custom element
    }
});
</code></pre>

        <p>
            To actually load the element, we'll have to first find the JS file to import, and then run its register function.
            By having the function that calls <code>customElements.define</code> as the default export by convention the problem is reduced to finding the path to the JS file.
            The following code uses a heuristic that assumes components are in a <code>./components/</code> subfolder of the current document
            and follow a consistent file naming scheme:
        </p>
        <pre><code>    #loadElement(element) {
        // strip leading x- off the name
        const cleanName = element.localName.replace(/^x-/, '').toLowerCase();
        // assume component is in its own folder
        const url = `./components/${cleanName}/${cleanName}.js`;
        // dynamically import, then register if not yet registered
        return import(new URL(url, document.location)).then(module =&gt; 
            !customElements.get(element.localName) &amp;&amp; module &amp;&amp; module.default());
    }</code></pre>

        <p>
            One could get a lot more creative however, and for example use an 
            <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap">import map</a> 
            to map module names to files. This I leave as an exercise for the reader.
        </p>

        <h3>Suspense</h3>

        <p>
            While the lazy component is loading, we can't show it yet. This is true for custom elements just as much as for React.
            That means we need a wrapper component that will show a fallback UI as long as any components in its subtree are loading,
            the <code>&lt;x-suspense&gt;</code> component. This starts out as a tale of two slots. When the suspense element is loading it shows the fallback, otherwise the content.
        </p>

        <pre><code>&lt;x-suspense&gt;
    &lt;p slot="fallback"&gt;Loading...&lt;/p&gt;
    &lt;x-lazy&gt;&lt;x-hello-world&gt;&lt;/x-hello-world&gt;&lt;/x-lazy&gt;
&lt;/x-suspense&gt;</code></pre>
        <pre><code>export class Suspense extends HTMLElement {
    #fallbackSlot;
    #contentSlot;

    set loading(isLoading) {
        if (!this.#fallbackSlot) return;
        this.#fallbackSlot.style.display = isLoading ? 'contents' : 'none';
        this.#contentSlot.style.display = !isLoading ? 'contents' : 'none';
    }

    constructor() {
        super();
        this.attachShadow({ mode: 'open' });

        this.#fallbackSlot = document.createElement('slot');
        this.#fallbackSlot.style.display = 'none';
        this.#fallbackSlot.name = 'fallback';
        this.#contentSlot = document.createElement('slot');
        this.shadowRoot.append(this.#fallbackSlot, this.#contentSlot);
    }

    connectedCallback() {
        this.style.display = 'contents';
    }
}
customElements.define('x-suspense', Suspense);</code></pre>

        <p>
            The trick now is, how to we get <code>loading = true</code> to happen?
            In Plain Vanilla's applications page I showed how a React context can be simulated using the <code>element.closest()</code> API.
            We can use the same mechanism to create a generic API that will let our suspense wait on a promise to complete.
        </p>

        <pre><code>    static waitFor(sender, ...promises) {
        const suspense = sender.closest('x-suspense');
        if (suspense) suspense.addPromises(...promises);
    }

    addPromises(...promises) {
        if (!promises.length) return;
        this.loading = true;
        // combine into previous promises if there are any
        const newPromise = this.#waitingForPromise = 
            Promise.allSettled([...promises, this.#waitingForPromise]);
        // wait for all promises to complete
        newPromise.then(_ =&gt; {
            // if no newer promises were added, we're done
            if (newPromise === this.#waitingForPromise) {
                this.loading = false;
            }
        });
    }</code></pre>

        <p>
            <code>Suspense.waitFor</code> will call the nearest ancestor <code>&lt;x-suspense&gt;</code>
            to a given element, and give it a set of promises that it should wait on.
            This API can then be called from our <code>&lt;x-lazy&gt;</code> component.
            Note that <code>#loadElement</code> returns a promise that completes when the custom element is loaded or fails to load.
        </p>
        <pre><code>    #loadLazy() {
        const elements = 
            [...this.children].filter(_ =&gt; _.localName.includes('-'));
        const unregistered = 
            elements.filter(_ =&gt; !customElements.get(_.localName));
        if (unregistered.length) {
            Suspense.waitFor(this, 
                ...unregistered.map(_ =&gt; this.#loadElement(_))
            );
        }
    }</code></pre>
        <p>
            The nice thing about the promise-based approach is that we can give it any promise, just like we would with React's suspense.
            For example, when loading data in a custom element that is in the suspense's subtree, we can call the exact same API:<br>
            <code>Suspense.waitFor(this, fetch(url).then(...))</code>
        </p>

        <h3>Error boundary</h3>

        <p>
            Up to this point, we've been assuming everything always works. This is <del>Sparta</del>software, it will never "always work".
            What we need is a graceful way to intercept failed promises that are monitored by the suspense,
            and show an error message instead. That is the role that React's error boundary plays.
        </p>
        <p>
            The approach is similar to suspense:
        </p>
        <pre><code>&lt;x-error-boundary&gt;
    &lt;p slot="error"&gt;Something went wrong&lt;/p&gt;
    &lt;x-suspense&gt;
        &lt;p slot="fallback"&gt;Loading...&lt;/p&gt;
        &lt;x-lazy&gt;&lt;x-hello-world&gt;&lt;/x-hello-world&gt;&lt;/x-lazy&gt;
    &lt;/x-suspense&gt;
&lt;/x-error-boundary&gt;</code></pre>
        <p>
            And the code is also quite similar to suspense:
        </p>
        <pre><code>export class ErrorBoundary extends HTMLElement {

    static showError(sender, error) {
        if (!error) throw new Error('ErrorBoundary.showError: expected two arguments but got one');
        const boundary = sender.closest('x-error-boundary');
        if (boundary) {
            boundary.error = error;
        } else {
            console.error('unable to find x-error-boundary to show error');
            console.error(error);
        }
    }

    #error;
    #errorSlot;
    #contentSlot;

    get error() {
        return this.#error;
    }

    set error(error) {
        if (!this.#errorSlot) return;
        this.#error = error;
        this.#errorSlot.style.display = error ? 'contents' : 'none';
        this.#contentSlot.style.display = !error ? 'contents' : 'none';
        if (error) {
            this.#errorSlot.assignedElements().forEach(element =&gt; {
                if (Object.hasOwn(element, 'error')) {
                    element.error = error;
                } else {
                    element.setAttribute('error', error?.message || error);
                }
            });
            this.dispatchEvent(new CustomEvent('error', { detail: error }));
        }
    }

    constructor() {
        super();
        this.attachShadow({ mode: 'open' });

        this.#errorSlot = document.createElement('slot');
        this.#errorSlot.style.display = 'none';
        this.#errorSlot.name = 'error';
        // default error message
        this.#errorSlot.textContent = 'Something went wrong.';
        this.#contentSlot = document.createElement('slot');
        this.shadowRoot.append(this.#errorSlot, this.#contentSlot);
    }

    reset() {
        this.error = null;
    }

    connectedCallback() {
        this.style.display = 'contents';
    }
}
customElements.define('x-error-boundary', ErrorBoundary);
</code></pre>

        <p>
            Similar to suspense, this has an API <code>ErrorBoundary.showError()</code> that can be called
            from anywhere inside the error boundary's subtree to show an error that occurs.
            The suspense component is then modified to call this API when it bumps into a rejected promise.
            To hide the error, the <code>reset()</code> method can be called on the error boundary element.
        </p>
        <p>
            Finally, the <code>error</code> setter will set the error as a property or attribute
            on all children in the error slot, which enables customizing the error message's behavior based on the error object's properties
            by creating a custom <code>&lt;x-error-message&gt;</code> component.
        </p>

        <h3>Conclusion</h3>

        <p>
            Finally, we can bring all of this together in a single example,
            that combines lazy, suspense, error boundary, a customized error message, and a lazy-loaded hello-world component.
        </p>

        <pre><code>import { registerLazy } from './components/lazy.js';
import { registerSuspense } from './components/suspense.js';
import { registerErrorBoundary } from './components/error-boundary.js';
import { registerErrorMessage } from './components/error-message.js';

customElements.define('x-demo', class extends HTMLElement {

    constructor() {
        super();
        registerLazy();
        registerSuspense();
        registerErrorBoundary();
        registerErrorMessage();
    }

    connectedCallback() {
        this.innerHTML = `
            &lt;p&gt;Lazy loading demo&lt;/p&gt;
            &lt;button id="lazy-load"&gt;Load lazy&lt;/button&gt;
            &lt;button id="error-reset" disabled&gt;Reset error&lt;/button&gt;
            &lt;div id="lazy-load-div"&gt;
                &lt;p&gt;Click to load..&lt;/p&gt;
            &lt;/div&gt;
        `;
        const resetBtn = this.querySelector('button#error-reset')
        resetBtn.onclick = () =&gt; {
            this.querySelector('x-error-boundary').reset();
            resetBtn.setAttribute('disabled', true);
        };
        const loadBtn = this.querySelector('button#lazy-load');
        loadBtn.onclick = () =&gt; {
            this.querySelector('div#lazy-load-div').innerHTML = `
                &lt;x-error-boundary&gt;
                    &lt;x-error-message slot="error"&gt;&lt;/x-error-message&gt;
                    &lt;x-suspense&gt;
                        &lt;p slot="fallback"&gt;Loading...&lt;/p&gt;
                        &lt;p&gt;&lt;x-lazy&gt;&lt;x-hello-world&gt;&lt;/x-hello-world&gt;&lt;/x-lazy&gt;&lt;/p&gt;
                    &lt;/x-suspense&gt;
                &lt;/x-error-boundary&gt;
            `
            this.querySelector('x-error-boundary').addEventListener('error', _ =&gt; {
                resetBtn.removeAttribute('disabled');
            });
            loadBtn.setAttribute('disabled', true);
        };
    }

});
</code></pre>
        <p><a href="https://plainvanillaweb.com/blog/articles/2024-09-09-sweet-suspense/example/index.html">complete example</a></p>

        <p>
            For the complete example's code, as well as the lazy, suspense and error-boundary components,
            check out the <a href="https://github.com/jsebrech/sweet-suspense">sweet-suspense repo on Github</a>.
        </p>
    ]]></content>
    </entry>
    <entry>
        <title><![CDATA[How fast are web components?]]></title>
        <link rel="alternate" type="text/html" href="https://plainvanillaweb.com/blog/articles/2024-09-06-how-fast-are-web-components/"/>
        <id>https://plainvanillaweb.com/blog/articles/2024-09-06-how-fast-are-web-components/</id>
        <published>2024-09-06T12:00:00.000Z</published>
        <updated>2024-09-06T12:00:00.000Z</updated>
        <summary><![CDATA[Benchmarking the relative performance of different web component techniques.]]></summary>
        <media:content url="https://plainvanillaweb.com/blog/articles/2024-09-06-how-fast-are-web-components/image.webp" type="image/webp" medium="image" />
        <author><name><![CDATA[Joeri Sebrechts]]></name></author>
        <content type="html"><![CDATA[
        <p>
            It is often said that web components are slow.
            This was also my experience when I first tried building web components a few years ago.
            At the time I was using the Stencil framework, because I didn't feel confident that they could be built well without a framework.
            Performance when putting hundreds of them on a page was so bad that I ended up going back to React.
        </p>
        <p>
            But as I've gotten deeper into vanilla web development I started to realize that maybe I was just using it wrong.
            Perhaps web components can be fast, if built in a light-weight way.
            This article is an attempt to settle the question "How fast are web components?".
        </p>

        <h3>The lay of the land</h3>

        <p>
            What kinds of questions did I want answered?
        </p>
        <ul>
            <li>How many web components can you render on the page in a millisecond?</li>
            <li>Does the technique used to built the web component matter, which technique is fastest?</li>
            <li>How do web component frameworks compare? I used Lit as the framework of choice as it is well-respected.</li>
            <li>How does React compare?</li>
            <li>What happens when you combine React with web components?</li>
        </ul>

        <p>
            To figure out the answer I made a benchmark as a vanilla web page (of course),
            that rendered 100.000 very simple components containing only <code>&lt;span&gt;.&lt;/span&gt;</code>
            and measured the elapsed time. This benchmark was then run on multiple devices and multiple browsers
            to figure out performance characteristics. The ultimate goal of this test is to figure out the absolute best performance
            that can be extracted from the most minimal web component.
        </p>

        <p>To get a performance range I used two devices for testing:</p>
        <ul>
            <li>A <em>Macbook Air M1</em> running MacOS, to stand in as the "fast" device, comparable to a new high end iPhone.</li>
            <li>An <em>Asus Chi T300 Core M</em> from 2015 running Linux Mint Cinnamon, to stand in as the "slow" device, comparable to an older low end Android.</li>
        </ul>
        <p>Between these devices is a 7x CPU performance gap.</p>

        <h3>The test</h3>

        <p>
            The test is simple: render 100.000 components using a specific technique, 
            call <code>requestAnimationFrame()</code> to make sure they actually render,
            then measure elapsed time. This produces a <em>components per millisecond</em> number.
        </p>
        <p>The techniques being compared:</p>
        <ul>
            <li><strong>innerHTML:</strong> each web component renders its content by assigning to <code>this.innerHTML</code></li>
            <li><strong>append:</strong> each web component creates the span using <code>document.createElement</code> and then appends it to itself</li>
            <li><strong>append (buffered):</strong> same as the append method, except all web components are first buffered to a document fragment which is then appended to the DOM</li>
            <li><strong>shadow + innerHTML:</strong> the same as innerHTML, except each component has a shadow DOM</li>
            <li><strong>shadow + append:</strong> the same as append, except each component has a shadow DOM</li>
            <li><strong>lit:</strong> each web component is rendered using the lit framework, in the way that its documentation recommends</li>
            <li><strong>template + append:</strong> each web component renders its content by cloning a template and appending it</li>
            <li><strong>react pure:</strong> rendering in React using a standard React component</li>
            <li><strong>react + wc:</strong> each React component wraps the append-style web component</li>
        </ul>
        <p>
            This test was run on M1 in Brave, Chrome, Edge, Firefox and Safari. And on Chi in Chrome and Firefox.
            It was run once to warm up the browser, then repeated three times.
        </p>

        <h3>The results</h3>

        <p>First, let's compare techniques. The number here is components per millisecond, so <strong>higher is better</strong>.</p>
        
        <table>
            <thead>
                <tr><th colspan="2">Chrome on M1, best of three</th></tr>
                <tr><th>technique</th><th>components/ms</th></tr>
            </thead>
            <tbody>
                <tr><td>innerHTML</td><td>143</td></tr>
                <tr><td>append</td><td>233</td></tr>
                <tr><td>append (buffered)</td><td>228</td></tr>
                <tr><td>shadow + innerHTML</td><td>132</td></tr>
                <tr><td>shadow + append</td><td>183</td></tr>
                <tr><td>lit</td><td>133</td></tr>
                <tr><td>template + append</td><td>181</td></tr>
                <tr><td>react pure</td><td>275</td></tr>
                <tr><td>react + wc</td><td>172</td></tr>
            </tbody>
        </table>

        <table>
            <thead>
                <tr><th colspan="2">Chrome on Chi, best of three</th></tr>
                <tr><th>technique</th><th>components/ms</th></tr>
            </thead>
            <tbody>
                <tr><td>innerHTML</td><td>25</td></tr>
                <tr><td>append</td><td>55</td></tr>
                <tr><td>append (buffered)</td><td>56</td></tr>
                <tr><td>shadow + innerHTML</td><td>24</td></tr>
                <tr><td>shadow + append</td><td>36</td></tr>
                <tr><td>lit</td><td>30</td></tr>
                <tr><td>template + append</td><td>45</td></tr>
                <tr><td>react pure</td><td>77</td></tr>
                <tr><td>react + wc</td><td>45</td></tr>
            </tbody>
        </table>

        <p>
            One relief right off the bat is that even the slowest implementation on the slow device
            renders 100.000 components in 4 seconds. React is faster than well-written web components, but never by more than 2x.
            That means for a typical web app performance is not a reason to avoid web components.
        </p>

        <p>
            As far as web component technique goes, the performance delta between the fastest and the slowest technique is around 2x,
            so again for a typical web app that difference will not matter. Things that slow down web components
            are shadow DOM and innerHTML. Appending cloned templates and avoiding shadow DOM is the right strategy
            for a well-performing web component.
        </p>

        <p>
            On the slow device the Lit framework is the worst performer, probably due to its use of shadow DOM and JS-heavy approaches.
            Meanwhile, pure React is the best performer, because while it does more work in creating the virtual DOM and diffing it to the real DOM,
            it benefits from not having to initialize the web component class instances.
            Consequently, when wrapping web components inside React components we see React's performance advantage disappear, and that it adds around a 20% performance tax.
        </p>

        <p>
            The fast device is up to 6x faster than the slow device in Chrome, depending on the technique used,
            so it is really worth testing applications on slow devices to get an idea of the range of performance.
        </p>

        <p>
            Next, let's compare browsers:
        </p>

        <table>
            <thead>
                <tr><th colspan="2">M1, append, best of three</th></tr>
                <tr><th>browser</th><th>components/ms</th></tr>
            </thead>
            <tbody>
                <tr><td>Brave</td><td>146</td></tr>
                <tr><td>Chrome</td><td>233</td></tr>
                <tr><td>Edge</td><td>224</td></tr>
                <tr><td>Firefox</td><td>232</td></tr>
                <tr><td>Safari</td><td>260</td></tr>
            </tbody>
        </table>

        <table>
            <thead>
                <tr><th colspan="2">Chi, append, best of three</th></tr>
                <tr><th>browser</th><th>components/ms</th></tr>
            </thead>
            <tbody>
                <tr><td>Chrome</td><td>55</td></tr>
                <tr><td>Firefox</td><td>180</td></tr>
            </tbody>
        </table>

        <p>
            Brave is really slow. Safari is pretty fast. Firefox is surprisingly decent,
            and actually a great performer on slow devices where it outshines Chrome by a lot.
            Using the "wrong" browser turns a fast machine into a slow machine (compare Brave on M1 to Firefox on Chi).
        </p>
        <p>
            There is a large performance gap when you compare the slowest technique on the slowest browser on the slowest device,
            with its fastest opposite combo. Specifically, there is a 13x performance gap:
        </p>
        <ul>
            <li>React pure, Safari on M1: 316 components/ms</li>
            <li>Shadow DOM + innerHTML, Chrome on Chi: 24 components/ms</li>
        </ul>
        <p>
            That means it becomes worthwhile to carefully consider technique when having to support a wide range of browsers and devices,
            because a bad combination may lead to a meaningfully degraded user experience.
        </p>
        
        <h3>Bottom line</h3>

        <p>
            I feel confident now that web components can be fast enough for almost all use cases where someone might consider React instead.
        </p>
        <p>
            However, it does matter how they are built. Shadow DOM should not be used for smaller often used web components,
            and the contents of those smaller components should be built using append operations instead of innerHTML.
            The use of web component frameworks might impact their performance significantly,
            and given how easy it is to write vanilla web components I personally don't see the point behind Lit or Stencil. YMMV.
        </p>

        <p>
            The full benchmark code and results can be <a href="https://github.com/jsebrech/vanilla-benchmarks">found on Github</a>.
        </p>

    ]]></content>
    </entry>
    <entry>
        <title><![CDATA[A unix philosophy for web development]]></title>
        <link rel="alternate" type="text/html" href="https://plainvanillaweb.com/blog/articles/2024-09-03-unix-philosophy/"/>
        <id>https://plainvanillaweb.com/blog/articles/2024-09-03-unix-philosophy/</id>
        <published>2024-09-03T12:00:00.000Z</published>
        <updated>2024-09-03T12:00:00.000Z</updated>
        <summary><![CDATA[Maybe all web components need to be a light-weight framework is the right set of helper functions.]]></summary>
        <media:content url="https://plainvanillaweb.com/blog/articles/2024-09-03-unix-philosophy/image.webp" type="image/webp" medium="image" />
        <author><name><![CDATA[Joeri Sebrechts]]></name></author>
        <content type="html"><![CDATA[
        <p>
            Web components have their malcontents. While frameworks have done their best to provide
            a place for web components to fit into their architecture, the suit never fits quite right,
            and framework authors have not been shy about expressing their disappointment.
            Here's Ryan Carniato of SolidJS explaining what's wrong with web components:
        </p>
        <blockquote>
            The collection of standards (Custom Elements, HTML Templates, Shadow DOM, and formerly HTML Imports) 
            put together to form Web Components on the surface seem like they could be used to replace 
            your favourite library or framework. But they are not an advanced templating solution. 
            They don't improve your ability to render or update the DOM. 
            They don't manage higher-level concerns for you like state management.
        </blockquote>
        <cite><a href="https://dev.to/ryansolid/maybe-web-components-are-not-the-future-hfh">Ryan Carniato</a></cite>
        <p>
            While this criticism is true, perhaps it's besides the point.
            Maybe web components were never meant to solve those problems anyway.
            Maybe there are ways to solve those problems in a way that dovetails with web components as they exist.
            In the main <a href="../../../pages/components.html">components tutorial</a> I've already explained what they <em>can</em> do,
            now let's see what can be done about the things that they <em>can't</em> do.
        </p>

        <h3>The Unix Philosophy</h3>

        <p>
            The Unix operating system carries with it a culture and philosophy of system design,
            which carries over to the command lines of today's Unix-like systems like Linux and MacOS. 
            This philosophy can be summarized as follows:
        </p>
        <ul>
            <li>Write programs that do one thing and do it well.</li>
            <li>Write programs to work together.</li>
            <li>Write programs to handle text streams, because that is a universal interface.</li>
        </ul>
        <p>
            What if we look at the various technologies that comprise web components as just programs, 
            part of a Unix-like system of web development that we collectively call the browser platform?
            In that system we can do better than text and use the DOM as the universal interface between programs, 
            and we can extend the system with a set of single purpose independent "programs" (functions) 
            that fully embrace the DOM by augmenting it instead of replacing it.
        </p>
        <p>
            In a sense this is the most old-school way of building web projects, the one people who "don't know any better"
            automatically gravitate to. What us old-school web developers did before Vue and Solid and Svelte, before Angular and React,
            before Knockout and Ember and Backbone, before even jQuery, was have a bunch of functions in <code>utilities.js</code>
            that we copied along from project to project.
            But, you know, sometimes old things can become new again.
        </p>
        <p>
            In previous posts I've already covered a <code>html()</code> function for <a href="../2024-08-25-vanilla-entity-encoding/">vanilla entity encoding</a>,
            and a <code>signal()</code> function that provides a <a href="../2024-08-30-poor-mans-signals/">tiny signals</a> implementation 
            that can serve as a lightweight system for state management.
            That still leaves a missing link between the state managed by the signals and the DOM that is rendered from safely entity-encoded HTML.
            What we need is a <code>bind()</code> function that can bind data to DOM elements and bind DOM events back to data.
        </p>

        <h3>Finding inspiration</h3>

        <p>
            In order to bind a template to data, we need a way of describing that behavior in the HTML markup.
            Well-trodden paths are often the best starting place to look for inspiration. I like <a href="https://vuejs.org/guide/essentials/template-syntax.html">Vue's template syntax</a>,
            because it is valid HTML but just augmented, and because it is proven. Vue's templates only pretend to be HTML
            because they're actually compiled to JavaScript behind the scenes, but let's start there as an API.
            This is what it looks like:
        </p>
        <dl>
            <dt><code>&lt;img :src="imageSrc" /&gt;</code></dt>
            <dd>Bind <em>src</em> to track the value of the <em>imageSrc</em> property of the current component.
                Vue is smart enough to set a property if one exists, and falls back to setting an attribute otherwise.
                (If that confuses you, read about <a href="https://javascript.info/dom-attributes-and-properties">attributes and properties</a> first.)</dd>
            <dt><code>&lt;button @click="doThis"&gt;&lt;/button&gt;</code></dt>
            <dd>Bind the <em>click</em> event to the <em>doThis</em> method of the current component.</dd>
        </dl>
        <p>
            By chance I came across this article about <a href="https://hawkticehurst.com/2024/05/bring-your-own-base-class/">making a web component base class</a>.
            In the section <em>Declarative interactivity</em> the author shows a way to do the Vue-like event binding syntax
            on a vanilla web component. This is what inspired me to develop the concept into a generic binding function and write this article.
        </p>

        <h3>Just an iterator</h3>

        <p>
            The heart of the binding function is an HTML fragment iterator. 
            After all, before we can bind attributes we need to first find the ones that have binding directives.
        </p>
        <pre><code>export const bind = (template) =&gt; {
    const fragment = template.content.cloneNode(true);
    // iterate over all nodes in the fragment
    const iterator = document.createNodeIterator(
        fragment,
        NodeFilter.SHOW_ELEMENT,
        {
            // reject any node that is not an HTML element
            acceptNode: (node) =&gt; {
                if (!(node instanceof HTMLElement))
                    return NodeFilter.FILTER_REJECT;
                return NodeFilter.FILTER_ACCEPT;
            },
        }
    );
    let node;
    while (node = iterator.nextNode()) {
        if (!node) return;
        const elem = node;
        for (const attr of Array(...node.attributes)) {
            // check for event binding directive
            if (attr.name.startsWith('@')) {

                // TODO: bind event ...
                
                elem.removeAttributeNode(attr);
            // check for property/attribute binding directive
            } else if (attr.name.startsWith(':')) {
                
                // TODO: bind data ...
                
                elem.removeAttributeNode(attr);
            }
        }
    }
    return fragment;
}</code></pre>
        <p>
            This code will take an <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template">HTML template element</a>, 
            clone it to a <a href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment">document fragment</a>, 
            and then iterate over all the nodes in the fragment, discovering their attributes. 
            Then for each attribute a check is made to see if it's a binding directive (@ or :). 
            The node is then bound to data according to the directive attribute (shown here as TODO's), 
            and the attribute is removed from the node. At the end the bound fragment is returned for inserting into the DOM.
        </p>
        <p>
            The benefit of using a fragment is that it is disconnected from the main DOM, while still offering all of the DOM API's. 
            That means we can easily create a node iterator to walk over it and discover all the attributes 
            with binding directives, modify those nodes and attributes in-place, and still be sure we're not causing 
            DOM updates in the main page until the fragment is inserted there. This makes the bind function very fast.
        </p>
        <p>
            If you're thinking "woah dude, that's a lot of code and a lot of technobabble, I ain't reading all that,"
            then please, I implore you to read through the code line by line, and you'll see it will all make sense.
        </p>
        <p>
            Of course, we also need to have something to bind <em>to</em>, so we need to add a second parameter.
            At the same time, it would be nice to just be able to pass in a string and have it auto-converted into a template.
            The beginning of our bind function then ends up looking like this:
        </p>
        <pre><code>export const bind = (template, target) =&gt; {
    if (!template.content) {
        const text = template;
        template = document.createElement('template');
        template.innerHTML = text;
    }
    const fragment = template.content.cloneNode(true);
// ...
}</code></pre>
        <p>That just leaves us the TODO's. We can make those as simple or complicated as we want. I'll pick a middle ground.</p>

        <h3>Binding to events</h3>

        <p>This 20 line handler binds events to methods, signals or properties:</p>
        <pre><code>// check for custom event listener attributes
if (attr.name.startsWith('@')) {
    const event = attr.name.slice(1);
    const property = attr.value;
    let listener;
    // if we're binding the event to a function, call it directly
    if (typeof target[property] === 'function') {
        listener = target[property].bind(target);
    // if we're binding to a signal, set the signal's value
    } else if (typeof target[property] === 'object' &amp;&amp; 
                typeof target[property].value !== 'undefined') {
        listener = e =&gt; target[property].value = e.target.value;
    // fallback: assume we're binding to a property, set the property's value
    } else {
        listener = e =&gt; target[property] = e.target.value;
    }
    elem.addEventListener(event, listener);
    // remove (non-standard) attribute from element
    elem.removeAttributeNode(attr);
}</code></pre>

        <p>That probably doesn't explain much, so let me give an example of what this enables:</p>
        <p><a href="https://plainvanillaweb.com/blog/articles/2024-09-03-unix-philosophy/example-bind3/example.html">Binding to events example</a></p>
        <pre><code>import { bind } from './bind.js';
import { signal } from './signals.js';

customElements.define('x-example', class Example extends HTMLElement {

    set a(value) { 
        this.setAttribute('a', value);
        this.querySelector('label[for=a] span').textContent = value;
    }
    set b(value) {
        this.setAttribute('b', value);
        this.querySelector('label[for=b] span').textContent = value;
    }
    c = signal('');

    connectedCallback() {
        this.append(bind(`
            &lt;div&gt;
                &lt;input id="a" type="number" @input="onInputA"&gt;
                &lt;label for="a"&gt;A = &lt;span&gt;&lt;/span&gt;&lt;/label&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;input id="b" type="number" @input="b"&gt;
                &lt;label for="b"&gt;B = &lt;span&gt;&lt;/span&gt;&lt;/label&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;input id="c" type="number" @input="c"&gt;
                &lt;label for="c"&gt;C = &lt;span&gt;&lt;/span&gt;&lt;/label&gt;
            &lt;/div&gt;
            &lt;button @click="onClick"&gt;Add&lt;/button&gt;
            &lt;div&gt;Result: &lt;span id="result"&gt;&lt;/span&gt;&lt;/div&gt;
        `, this));
        this.c.effect(() =&gt; 
            this.querySelector('label[for=c] span').textContent = this.c);
    }

    onInputA (e) {
        this.a = e.target.value;
    }

    onClick() {
        this.querySelector('#result').textContent =
            +this.getAttribute('a') + +this.getAttribute('b') + +this.c;
    }
});
</code></pre>

        <ul>
            <li><code>input#a</code>'s input event is handled by calling the <code>onClickA()</code> method.</li>
            <li><code>input#b</code>'s input event is handled by assigning <code>e.target.value</code> to the <code>b</code> property.</li>
            <li><code>input#c</code>'s input event is handled by setting the value of the <code>c</code> signal.</li>
        </ul>
        <p>
            If you're not familiar with the <code>signal()</code> function, check out the <a href="../2024-08-30-poor-mans-signals/">tiny signals</a> 
            implementation in the previous post. For now you can also just roll with it.
        </p>
        <p>Not a bad result for 20 lines of code.</p>

        <h3>Binding to data</h3>
        <p>
            Having established the pattern for events that automatically update properties, 
            we now reverse the polarity to make data values automatically set element properties or attributes.
        </p>
        <pre><code>// ...
    if (attr.name.startsWith(':')) {
        // extract the name and value of the attribute/property
        let name = attr.name.slice(1);
        const property = getPropertyForAttribute(name, target);
        const setter = property ?
            () =&gt; elem[property] = target[attr.value] :
            () =&gt; elem.setAttribute(name, target[attr.value]);
        setter();
        // if we're binding to a signal, listen to updates
        if (target[attr.value]?.effect) {
            target[attr.value].effect(setter);
        // if we're binding to a property, listen to the target's updates
        } else if (target.addEventListener) {
            target.addEventListener('change', setter);
        }
        // remove (non-standard) attribute from element
        elem.removeAttributeNode(attr);
    }
// ...

function getPropertyForAttribute(name, obj) {
    switch (name.toLowerCase()) {
        case 'text': case 'textcontent':
            return 'textContent';
        case 'html': case 'innerhtml':
            return 'innerHTML';
        default:
            for (let prop of Object.getOwnPropertyNames(obj)) {
                if (prop.toLowerCase() === name.toLowerCase()) {
                    return prop;
                }
            }   
    }
}</code></pre>
        <p>
            The <code>getPropertyForAttribute</code> function is necessary because the attributes that contain the directives
            will have names that are case-insensitive, and these must be mapped to property names that are case-sensitive.
            Also, the <code>:text</code> and <code>:html</code> shorthand notations replace the role of <code>v-text</code>
            and <code>v-html</code> in Vue's template syntax.
        </p>
        <p>
            When the value of the target's observed property changes, we need to update the bound element's property or attribute.
            This means a triggering <code>'change'</code> event is needed that is then subscribed to.
            A framework's templating system will compare state across time, and detect the changed values automatically. 
            Lacking such a system we need a light-weight alternative.
        </p>
        <p>
            When the property being bound to is a signal, this code registers an effect on the signal.
            When the property is just a value, it registers an event listener on the target object,
            making it the responsibility of that target object to dispatch the <code>'change'</code> event when values change.
            This approach isn't going to get many points for style, but it does work.
        </p>
        <p>
            Check out the <a href="example-combined/bind.js">completed bind.js</a> code.
        </p>

        <h3>Bringing the band together</h3>

        <p>
            In the article <a href="https://dev.to/richharris/why-i-don-t-use-web-components-2cia">Why I don't use web components</a> 
            Svelte's Rich Harris lays out the case against web components. He demonstrates how this simple 9 line Svelte component
            <code>&lt;Adder a={1} b={2}/&gt;</code> becomes an incredible verbose 59 line monstrosity when ported to a vanilla web component.
        </p>
        <pre><code>&lt;script&gt;
  export let a;
  export let b;
&lt;/script&gt;

&lt;input type="number" bind:value={a}&gt;
&lt;input type="number" bind:value={b}&gt;

&lt;p&gt;{a} + {b} = {a + b}&lt;/p&gt;</code></pre>

        <p>
            Now that we have assembled our three helper functions <code>html()</code>, <code>signal()</code> and <code>bind()</code>
            on top of the web components baseline, at a total budget of around 150 lines of code, how close can we get for a web component <code>&lt;x-adder a="1" b="2"&gt;&lt;/x-adder&gt;</code>?
        </p>
        <pre><code>import { bind } from './bind.js';
import { signal, computed } from './signals.js';
import { html } from './html.js';

customElements.define('x-adder', class Adder extends HTMLElement {
    a = signal();
    b = signal();
    result = computed(() =&gt; 
        html`${+this.a} + ${+this.b} = ${+this.a + +this.b}`, [this.a, this.b]);

    connectedCallback() {
        this.a.value ??= this.getAttribute('a') || 0;
        this.b.value ??= this.getAttribute('b') || 0;
        this.append(bind(html`
            &lt;input type="number" :value="a" @input="a" /&gt;
            &lt;input type="number" :value="b" @input="b" /&gt;
            &lt;p :html="result"&gt;&lt;/p&gt;
        `, this));
    }
});
</code></pre>
        <p><a href="https://plainvanillaweb.com/blog/articles/2024-09-03-unix-philosophy/example-combined/example.html">combined example</a></p>

        <p>
            To be fair, that's still twice the lines of code, but it describes clearly what it does, and really that is all you need. 
            And I'm just shooting in the wind here, trying stuff out.
            Somewhere out there could be a minimal set of functions that transforms web components into something resembling a framework,
            and the idea excites me! Who knows, maybe in a few years the web community will return to writing projects in 
            vanilla web code, dragging along the modern equivalent of <code>utilities.js</code> from project to project...
        </p>
        <br>
        <p><em>What do you think?</em></p>
    ]]></content>
    </entry>
    <entry>
        <title><![CDATA[Poor man's signals]]></title>
        <link rel="alternate" type="text/html" href="https://plainvanillaweb.com/blog/articles/2024-08-30-poor-mans-signals/"/>
        <id>https://plainvanillaweb.com/blog/articles/2024-08-30-poor-mans-signals/</id>
        <published>2024-08-30T12:00:00.000Z</published>
        <updated>2024-08-30T12:00:00.000Z</updated>
        <summary><![CDATA[Signals are all the rage over in frameworkland, so let's bring them to vanilla JS.]]></summary>
        <media:content url="https://plainvanillaweb.com/blog/articles/2024-08-30-poor-mans-signals/image.webp" type="image/webp" medium="image" />
        <author><name><![CDATA[Joeri Sebrechts]]></name></author>
        <content type="html"><![CDATA[
        <p>
            Signals are all the rage right now. Everyone's doing them.
            <a href="https://angular.dev/guide/signals">Angular</a>,
            and <a href="https://docs.solidjs.com/concepts/signals">Solid</a>,
            and <a href="https://preactjs.com/guide/v10/signals/">Preact</a>,
            and there are third party packages for just about every framework that doesn't already have them.
            There's even a <a href="https://github.com/tc39/proposal-signals">proposal</a>
            to add them to the language, and if that passes it's just a 
            <a href="https://thenewstack.io/did-signals-just-land-in-react/">matter of time</a> before all frameworks 
            have them built in.
        </p>

        <h3>Living under a rock</h3>
        <p>
            In case you've been living under a rock, here's the example from Preact's documentation 
            that neatly summarizes what signals do:
        </p>
        <pre><code>import { signal, computed, effect } from "@preact/signals";

const name = signal("Jane");
const surname = signal("Doe");
const fullName = computed(() =&gt; `${name.value} ${surname.value}`);

// Logs name every time it changes:
effect(() =&gt; console.log(fullName.value));
// Logs: "Jane Doe"

// Updating `name` updates `fullName`, which triggers the effect again:
name.value = "John";
// Logs: "John Doe"
</code></pre>
        <p>
            Simply put, signals wrap values and computations 
            in a way that allows us to easily respond to every change to those values and results in a targeted way,
            without having to rerender the entire application in the way that we would do in React.
            In short, signals are an efficient and targeted way to respond to changes without having to do state comparison and DOM-diffing.
        </p>
        <p>
            OK, so, if signals are so great, why am I trying to sell you on them on a vanilla web development blog?
            Don't worry! Vanilla web developers can have signals too.
        </p>

        <h3>Just a wrapper</h3>
        <p>
            Signals are at heart nothing more than a wrapper for a value that sends events when the value changes.
            That's nothing that a little trickery with the not well known but very handy <code>EventTarget</code> base class can't fix for us.
        </p>
        <pre><code>class Signal extends EventTarget {
    #value;
    get value () { return this.#value; }
    set value (value) {
        if (this.#value === value) return;
        this.#value = value;
        this.dispatchEvent(new CustomEvent('change')); 
    }

    constructor (value) {
        super();
        this.#value = value;
    }
}</code></pre>
        <p>
            This gets us a very barebones signals experience:
        </p>
        <pre><code>const name = new Signal('Jane');
name.addEventListener('change', () =&gt; console.log(name.value));
name.value = 'John';
// Logs: John</code></pre>
        <p>
            But that's kind of ugly. The <code>new</code> keyword went out of fashion a decade ago,
            and that <code>addEventListener</code> sure is unwieldy.
            So let's add a little syntactic sugar.
        </p>
        <pre><code>class Signal extends EventTarget {
    #value;
    get value () { return this.#value; }
    set value (value) {
        if (this.#value === value) return;
        this.#value = value;
        this.dispatchEvent(new CustomEvent('change')); 
    }

    constructor (value) {
        super();
        this.#value = value;
    }

    effect(fn) {
        fn();
        this.addEventListener('change', fn);
        return () =&gt; this.removeEventListener('change', fn);
    }

    valueOf () { return this.#value; }
    toString () { return String(this.#value); }
}

const signal = _ =&gt; new Signal(_);
</code></pre>
        <p>
            Now our barebones example is a lot nicer to use:
        </p>
        <pre><code>const name = signal('Jane');
name.effect(() =&gt; console.log(name.value));
// Logs: Jane
name.value = 'John';
// Logs: John</code></pre>
        <p>
            The <code>effect(fn)</code> method will call the specified function,
            and also subscribe it to changes in the signal's value.
        </p>
        <p>
            It also returns a dispose function that can be used to unregister the effect.
            However, a nice side effect of using <code>EventTarget</code> and browser built-in events as the reactivity primitive
            is that it makes the browser smart enough to garbage collect the signal and its effect when the signal goes out of scope.
            This means less chance for memory leaks even if we never call the dispose function.
        </p>
        <p>
            Finally, the <code>toString</code> and <code>valueOf</code> magic methods allow for dropping <code>.value</code> in most places
            that the signal's value gets used. (But not in this example, because the console is far too clever for that.)
        </p>

        <h3>Does not compute</h3>
        <p>
            This signals implementation is already capable, but at some point it might be handy to have an effect based on more than one signal.
            That means supporting computed values. Where the base signals are a wrapper around a value,
            computed signals are a wrapper around a function.
        </p>
        <pre><code>class Computed extends Signal {
    constructor (fn, deps) {
        super(fn(...deps));
        for (const dep of deps) {
            if (dep instanceof Signal) 
                dep.addEventListener('change', () =&gt; this.value = fn(...deps));
        }
    }
}

const computed = (fn, deps) =&gt; new Computed(fn, deps);
</code></pre>
        <p>
            The computed signal calculates its value from a function.
            It also depends on other signals, and when they change it will recompute its value.
            It's a bit obnoxious to have to pass the signals that it depends on
            as an additional parameter, but hey, I didn't title this article <em>Rich man's signals</em>.
        </p>
        <p>
            This enables porting Preact's signals example to vanilla JS.
        </p>
        <pre><code>const name = signal('Jane');
const surname = signal('Doe');
const fullName = computed(() =&gt; `${name} ${surname}`, [name, surname]);
// Logs name every time it changes:
fullName.effect(() =&gt; console.log(fullName.value));
// -&gt; Jane Doe

// Updating `name` updates `fullName`, which triggers the effect again:
name.value = 'John';
// -&gt; John Doe
</code></pre>

        <h3>Can you use it in a sentence?</h3>
        <p>
            You may be thinking, all these <code>console.log</code> examples are fine and dandy,
            but how do you use this stuff in actual web development?
            This simple adder demonstrates how signals can be combined with web components:
        </p>
        <pre><code>import { signal, computed } from './signals.js';

customElements.define('x-adder', class extends HTMLElement {
    a = signal(1);
    b = signal(2);
    result = computed((a, b) =&gt; `${a} + ${b} = ${+a + +b}`, [this.a, this.b]);

    connectedCallback() {
        if (this.querySelector('input')) return;

        this.innerHTML = `
            &lt;input type="number" name="a" value="${this.a}"&gt;
            &lt;input type="number" name="b" value="${this.b}"&gt;
            &lt;p&gt;&lt;/p&gt;
        `;
        this.result.effect(
            () =&gt; this.querySelector('p').textContent = this.result);
        this.addEventListener('input', 
            e =&gt; this[e.target.name].value = e.target.value);
    }
});
</code></pre>
        <p>
            And here's a live demo:
        </p>
        <p><a href="https://plainvanillaweb.com/blog/articles/2024-08-30-poor-mans-signals/adder.html">adder.html</a></p>
        <p>
            In case you were wondering, the <code>if</code> is there to prevent adding the effect twice
            if connectedCallback is called when the component is already rendered.
        </p>
        <p>
            The full poor man's signals code in all its 36 line glory can be found in the <a href="https://github.com/jsebrech/tiny-signals/">tiny-signals repo</a> on Github.
        </p>
    ]]></content>
    </entry>
    <entry>
        <title><![CDATA[Vanilla entity encoding]]></title>
        <link rel="alternate" type="text/html" href="https://plainvanillaweb.com/blog/articles/2024-08-25-vanilla-entity-encoding/"/>
        <id>https://plainvanillaweb.com/blog/articles/2024-08-25-vanilla-entity-encoding/</id>
        <published>2024-08-25T12:00:00.000Z</published>
        <updated>2024-08-25T12:00:00.000Z</updated>
        <summary><![CDATA[The first version of this site didn't use entity encoding in the examples. Now it does.]]></summary>
        <media:content url="https://plainvanillaweb.com/blog/articles/2024-08-25-vanilla-entity-encoding/image.webp" type="image/webp" medium="image" />
        <author><name><![CDATA[Joeri Sebrechts]]></name></author>
        <content type="html"><![CDATA[
        <h3>Good enough</h3>
        <p>
            When I made the first version of the Plain Vanilla website, there were things that I would have liked
            to spend more time on, but that I felt didn't belong in a Good Enough™ version of the site.
            One of those things was defending against <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html">Cross-Site Scripting</a> (XSS).
        </p>
        <p>
            XSS is still in the <a href="https://owasp.org/www-project-top-ten/">OWASP Top Ten</a> of security issues, 
            but it's no longer as prevalent as it used to be. Frameworks have built in a lot of defenses, 
            and when using their templating systems you have to go out of your way to inject code into the generated HTML.
            When eschewing frameworks we're reduced to standard templating in our web components, and those offer no defense against XSS.
        </p>
        <p>
            Because of this, in the original site the <a href="https://plainvanillaweb.com/pages/components.html#passing-data">Passing Data example</a> 
            on the <em>Components</em> page had an undocumented XSS bug.
            The <em>name</em> field could have scripts injected into it. I felt ambivalent about leaving that bug in.
            On the one hand, the code was very compact and neat by leaving it in.
            On the other hand it made that code a bad example that shouldn't be copied.
            I ended up choosing to leave it as-is because an example doesn't have to be production-grade
            and generating properly encoded HTML was not the point of that specific example.
            It's time however to circle back to that XSS bug and figure out how it would have been solved in a clean and readable way,
            if Santa really did want to bring his List application to production-level quality.
        </p>

        <h3>The problem</h3>
        <p>
            The basic problem we need to solve is that vanilla web components end up having a lot of code that looks like this:
        </p>
        <pre><code>class MyComponent extends HTMLElement {
    connectedCallback() {
        const btn = `&lt;button&gt;${this.getAttribute('foo')}&lt;/button&gt;`;
        this.innerHTML = `
            &lt;header&gt;&lt;h1&gt;${this.getAttribute('bar')}&lt;/h1&gt;&lt;/header&gt;
            &lt;article&gt;
                &lt;p class="${this.getAttribute('baz')}"&gt;${this.getAttribute('xyzzy')}&lt;/p&gt;
                ${btn}
            &lt;/article&gt;
        `;
    }
}
customElements.define('my-component', MyComponent);</code></pre>
        <p>
            If any of <code>foo</code>, <code>bar</code>, <code>baz</code> or <code>xyzzy</code> contain one of the dangerous HTML entities,
            we risk seeing our component break, and worst-case risk seeing an attacker inject a malicious payload into the page.
            Just as a reminder, those dangerous HTML entities are &lt;, &gt;, &amp;, ' and ".
        </p>

        <h3>The fix, take one</h3>
        <p>
            A naive fix is creating a html-encoding function and using it consistently:
        </p>
        <pre><code>function htmlEncode(s) {
    return s.replace(/[&amp;&lt;&gt;'"]/g,
        tag =&gt; ({
            '&amp;': '&amp;amp;',
            '&lt;': '&amp;lt;',
            '&gt;': '&amp;gt;',
            "'": '&amp;#39;',
            '"': '&amp;quot;'
        }[tag]))
}

class MyComponent extends HTMLElement {
    connectedCallback() {
        const btn = `&lt;button&gt;${htmlEncode(this.getAttribute('foo'))}&lt;/button&gt;`;
        this.innerHTML = `
            &lt;header&gt;&lt;h1&gt;${htmlEncode(this.getAttribute('bar'))}&lt;/h1&gt;&lt;/header&gt;
            &lt;article&gt;
                &lt;p class="${htmlEncode(this.getAttribute('baz'))}"&gt;${htmlEncode(this.getAttribute('xyzzy'))}&lt;/p&gt;
                ${btn}
            &lt;/article&gt;
        `;
    }
}
customElements.define('my-component', MyComponent);</code></pre>
        <p>
            While this does work to defend against XSS, it is verbose and ugly, not pleasant to type and not pleasant to read.
            What really kills it though, is that it assumes attention to detail from us messy humans. We can never forget,
            never ever, to put a <code>htmlEncode()</code> around each and every variable.
            In the real world, that is somewhat unlikely.
        </p>
        <p>
            What is needed is a solution that allows us to forget about entity encoding, by doing it automatically
            when we're templating. I drew inspiration from templating libraries that work in-browser and are based on tagged templates, 
            like <a href="https://lit.dev/docs/api/templates/#html">lit-html</a> 
            and <a href="https://github.com/developit/htm">htm</a>. The quest was on to build the most minimalistic
            html templating function that encoded entities automatically.
        </p>

        <h3>The fix, take two</h3>
        <p>
            Ideally, the fixed example should look more like this:
        </p>
        <pre><code>import { html } from './html.js';

class MyComponent extends HTMLElement {
    connectedCallback() {
        const btn = html`&lt;button&gt;${this.getAttribute('foo')}&lt;/button&gt;`;
        this.innerHTML = html`
            &lt;header&gt;&lt;h1&gt;${this.getAttribute('bar')}&lt;/h1&gt;&lt;/header&gt;
            &lt;article&gt;
                &lt;p class="${this.getAttribute('baz')}"&gt;${this.getAttribute('xyzzy')}&lt;/p&gt;
                ${btn}
            &lt;/article&gt;
        `;
    }
}
customElements.define('my-component', MyComponent);</code></pre>
        <p>
            The <code>html``</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates">tagged template function</a> 
            would automatically encode entities, in a way that we don't even have to think about it.
            Even when we nest generated HTML inside of another template, like with <code>${btn}</code>, it should just magically work.
            It would be so minimal as to disappear in the background, barely impacting readability, maybe even improving it.
            You may be thinking that doing that correctly would involve an impressive amount of code. I must disappoint.
        </p>
        <pre><code>class Html extends String { }

/** 
 * tag a string as html not to be encoded
 * @param {string} str
 * @returns {string}
 */
export const htmlRaw = str =&gt; new Html(str);

/** 
 * entity encode a string as html
 * @param {*} value The value to encode
 * @returns {string}
 */
export const htmlEncode = (value) =&gt; {
    // avoid double-encoding the same string
    if (value instanceof Html) {
        return value;
    } else {
        // https://stackoverflow.com/a/57448862/20980
        return htmlRaw(
            String(value).replace(/[&amp;&lt;&gt;'"]/g, 
                tag =&gt; ({
                    '&amp;': '&amp;amp;',
                    '&lt;': '&amp;lt;',
                    '&gt;': '&amp;gt;',
                    "'": '&amp;#39;',
                    '"': '&amp;quot;'
                }[tag]))
        );
    }
}

/** 
 * html tagged template literal, auto-encodes entities
 */
export const html = (strings, ...values) =&gt; 
    htmlRaw(String.raw({ raw: strings }, ...values.map(htmlEncode)));
</code></pre>
        <p>
            Those couple dozen lines of code are all that is needed. Let's go through it from top to bottom.
        </p>
        <dl>
            <dt><code>class Html extends String { }</code></dt>
            <dd>The Html class is used to mark strings as encoded, so that they won't be encoded again.</dd>
            <dt><code>export const htmlRaw = str =&gt; new Html(str);</code></dt>
            <dd>Case in point, the htmlRaw function does the marking.</dd>
            <dt><code>export const htmlEncode = ...</code></dt>
            <dd>The earlier htmlEncode function is still doing useful work, only this time it will mark the resulting string as HTML, and it won't double-encode.</dd>
            <dt><code>export const html = ...</code></dt>
            <dd>The tagged template function that binds it together.</dd>
        </dl>

        <p>
            A nice upside of the html template function is that the <em>html-in-template-string</em> Visual Studio Code extension
            can detect it automatically and will syntax highlight the templated HTML. This is what example 3 looked like after I made it:
        </p>

        <img src="https://plainvanillaweb.com/blog/articles/2024-08-25-vanilla-entity-encoding/syntax-highlighting.webp" alt="example 3 with syntax highlighting">

        <p>
            Granted, there's still a bunch of boilerplate here, and that <code>getAttribute</code> gets unwieldy.
            But with this syntax highlighting enabled sometimes when I'm working on vanilla web components I forget it's not React and JSX, but just HTML and JS.
            It's surprising how nice of a development experience web standards can be if you embrace them.
        </p>

        <p>
            I decided to leave the XSS bug in the <em>Passing Data</em> example, but now the <em>Applications</em> page
            has an explanation about entity encoding documenting this html template function.
            I can only hope people that work their way through the tutorial make it that far.
            For your convenience I also put the HTML templating function in its own separate 
            <a href="https://github.com/jsebrech/html-literal">html-literal repo on Github</a>.
        </p>

    ]]></content>
    </entry>
    <entry>
        <title><![CDATA[Let's build a blog, vanilla-style!]]></title>
        <link rel="alternate" type="text/html" href="https://plainvanillaweb.com/blog/articles/2024-08-17-lets-build-a-blog/"/>
        <id>https://plainvanillaweb.com/blog/articles/2024-08-17-lets-build-a-blog/</id>
        <published>2024-08-17T12:00:00.000Z</published>
        <updated>2024-08-26T12:00:00.000Z</updated>
        <summary><![CDATA[Explaining how this vanilla web development blog was built, using nothing but vanilla web techniques.]]></summary>
        <media:content url="https://plainvanillaweb.com/blog/articles/2024-08-17-lets-build-a-blog/image.webp" type="image/webp" medium="image" />
        <author><name><![CDATA[Joeri Sebrechts]]></name></author>
        <content type="html"><![CDATA[
        <p>
            As I write this paragraph it is my birthday, and it seemed like as good an opportunity as any to start a blog about vanilla web development.
            This blog post will be a bit unusual, as I will be writing it while I'm making the blog's inner workings.
            But before I get around to figuring out and then explaining how it was made, let me start with why.
        </p>

        <section>
            <h3>Origin story</h3>
            <p>
                I have been building web sites since the late 90's, and over the years there were always two constants:
                (1) browsers were terrible developer platforms, (2) new tools and frameworks built ever taller on top of them.
                The tools were necessary, but their growing complexity frustrated me, and in that frustration lies the origin of this blog.
            </p>
            <p>
                A few years ago something unexpected happened: Microsoft moved away from their (underfeatured) Trident browser engine.
                Suddenly there was a new baseline of browsers, a capable baseline. Browsers got good!
                I explored what modern browsers could do as a developer platform, and grew excited with the possibilities
                to treat the browser itself as the framework, without a middleman. 
                That eventually led into making the <a href="https://plainvanillaweb.com">Plain Vanilla website</a>, a framework tutorial for the web standards platform.
            </p>
            <p>
                In building this website editorial choices had to be made.
                Trying to explain too much would only confuse people, so the tutorial was trimmed of its fat.
                There is however so much more to explore, and that is where this blog enters the picture.
                Here I will talk about some of the things that didn't find a home in the Plain Vanilla tutorial,
                and document the new things that do.
            </p> 
        </section>

        <section>
            <h3>What is a blog anyway?</h3>

            <p>
                Of course, a blog about vanilla web development has to be built vanilla-style.
                That means no build steps, no server-side logic, no frameworks or libraries.
                Bottom line that means throwing up a bunch of HTML pages with an index page linking them together,
                but that by itself isn't enough. The idea is to make a full-fat modern feeling blog,
                something that has what people expect a blog to have. So off I went to look at popular blogs and build a list of features.
            </p>
            <p>A <em>modern</em> blog will have ...</p> 
            <ul>
                <li>One page per article, easy for sharing as a link and discovery by Google.</li>
                <li>A welcome page, with one or more hero cards leading to articles and a list of cards for recent articles.</li>
                <li>An archive page, with the full history of articles linking to the article pages.</li>
                <li>An RSS feed, for the 20 most recent articles, containing the full text.</li>
                <li>Comments on every article. This is a big one.</li>
                <li>Some colors and imagery, to spruce things up and please the readers.</li>
                <li>Easy to author articles. This is also a big one.</li>
            </ul>
            <p>The challenge was: how to do all of that within the vanilla constraints that I set myself?</p>
        </section>

        <section>
            <h3>Article-first design</h3>

            <p>
                The core of the blog experience is the article, so getting that right is key and that makes it the best place to start.
                Lacking any kind of generator or server-side routing, each article has to be written as a discrete html page
                in order to be discoverable by Google. Authoring those html pages should be straightforward,
                with minimal boilerplate.
            </p>

            <p>After careful consideration we present to you, an article page blueprint...</p>
            <pre><code>&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;title&gt;A spiffy title!&lt;/title&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" /&gt;
    &lt;meta name="description" content="This is a spiffy article. You should read it."&gt;
    &lt;link rel="stylesheet" href="index.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;blog-header published="2024-08-17"&gt;
        &lt;img src="image.jpeg" alt="Another AI image" loading="lazy" /&gt;
        &lt;h2&gt;A spiffy title!&lt;/h2&gt;
        &lt;p class="byline" aria-label="author"&gt;Malkovich&lt;/p&gt;
    &lt;/blog-header&gt;
    &lt;main&gt;
        Article text goes here ...
    &lt;/main&gt;
    &lt;blog-footer mastodon-url="https://example.com/@jmalkovich/12345"&gt;&lt;/blog-footer&gt;
    &lt;script type="module" src="index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

            <p>
                This does several things for me. It keeps the &lt;head&gt; section as minimal as possible.
                It also moves the navigation at the top and bottom into dedicated web components.
                The header component accepts the article's image and title as child elements,
                neatly leaving the main element containing just the article's content and nothing else,
                making it easy to extract (but more on that later).
            </p>
            <p>
                When users have scripting disabled they won't get the header navigation, 
                but thanks to this CSS they do get a warning:<br>
                <code>@media (scripting: none) { blog-header::before { content: ' ... ' } }</code><br>
                This approach frees me from thinking about noscript warnings while writing an article.
            </p>
            <p>
                Finally, for comments I considered Disqus, but didn't want to include their embed.
                So instead the footer accepts the URL to a mastodon toot about the article,
                and will automatically generate a link that goes there. Given that the blog has a technical audience
                I'm pretty sure they can figure out how to reply over there. This approach can be extended
                to <a href="https://carlschwan.eu/2020/12/29/adding-comments-to-your-static-blog-with-mastodon/">show replies inline on the page</a>
                by calling the Mastodon API, but I didn't tackle that yet. It's somewhat cumbersome to first post an article, 
                then toot about it, and then update the article with the toot's URL, but I'll survive.
                Incidentally, I still giggle like a schoolgirl inside my head every time I type the word <em>toot</em>.
            </p>
        </section>

        <section>
            <h3>Organizing files</h3>

            <p>
                Next comes the question how to organize the article files into a coherent structure.
                After thinking it over, this is what I landed on:
            </p>
            <ul>
                <li><code>articles/</code>
                    <ul>
                        <li><code><em>YYYY-MM-DD</em>-some-blog-title/</code>
                            <ul>
                                <li><code>index.html</code></li>
                                <li><code>image.jpeg</code></li>
                                <li>other files used in the article ...</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><code>components/</code>: the blog's shared web components</li>
                <li><code>index.html</code>: the main landing page</li>
                <li><code>archive.html</code>: the archives page</li>
                <li><code>index.js/css</code>: shared resources</li>
                <li><code>feed.xml</code>: the RSS feed</li>
            </ul>
            <p>
                By wrapping every article and all its resources into a folder, each article can get as messy and complicated as it wants.
                The shared index.js and index.css is separate from that of the main site
                to keep the blog's resources out of the Plain Vanilla site's pages, and vice versa.
            </p>
        </section>

        <section>
            <h3>Building indexes</h3>

            <p>
                You wouldn't think a blog has a need for many indexes, but in fact this modest blog will have three:
            </p>
            <ol>
                <li>The recent posts section on the main landing page</li>
                <li>The recent posts in the RSS feed</li>
                <li>The full list of articles in the archive page</li>
            </ol>
            <p>
                Visually showing an index is not so difficult, as a web component built around a simple <code>&lt;li&gt;</code>-based
                card design can be used to show both the recent posts and the archive page, and was straighforward to style with CSS.
            </p>
            <pre><code>&lt;ul class="cards"&gt;
    &lt;li class="card"&gt;
        &lt;img src="./articles/2024-08-17-lets-build-a-blog/image.webp" aria-hidden="true" loading="lazy" /&gt;
        &lt;h3&gt;&lt;a href="./articles/2024-08-17-lets-build-a-blog/"&gt;Let's build a blog, vanilla-style!&lt;/a&gt;&lt;/h3&gt;
        &lt;p&gt;Explaining how this vanilla web development blog was built, using nothing but vanilla web techniques.&lt;/p&gt;
        &lt;small&gt;
            &lt;time datetime="2024-08-17"&gt;August 17, 2024&lt;/time&gt;
        &lt;/small&gt;
    &lt;/li&gt;
&lt;/ul&gt;</code></pre>
            <p>
                Getting that data in a convenient form however is another matter.
                The RSS feed contains full text contents, so needs a separate step to build from the articles' HTML.
                The recent posts section on the index page thankfully can be built by reading the RSS feed,
                so was trivial to solve with a <code>&lt;blog-latest-posts&gt;</code> web component once the feed was set up.
                The full list of articles however cannot, as the RSS feed would grow too large if it contained all posts.
                So the archive page needs another separate step to build the full list of links from the folder of articles.
            </p>
            <p>
                For these build steps I considered various options:
            </p>
            <dl>
                <dt>❌ <del>Manually keeping the files in sync</del></dt><dt>
                </dt><dd>
                    It sounded like a lot of work, and error-prone, so a hard no on that one.
                </dd>
                <dt>❌ <del>A generator script, and a package.json</del></dt>
                <dd>
                    This is what I would normally go for, relying on a bunch of npm dependencies and a bunch of scripting
                    to process the articles into the index files that are needed. 
                    It felt like cheating to bring in node and its ecosystem, so again this was a no.
                </dd>
                <dt>✅ A separate generator webpage</dt>
                <dd>
                    I've wanted to play around with the
                    <a href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_API">File System API</a>
                    for a while, and this seemed a good opportunity.
                    Turning the generator into a webpage also leaves options for actually running the web components
                    and extracting their dynamically rendered content.
                </dd>
            </dl>

            <p>
                For the generator page I built a dedicated web component that allows opening or dropping the
                local <code>blog/</code> folder with the newly written or updated articles,
                and then will process those into a <code>feed.xml</code> and <code>index.json</code>.
                The JSON file is used to load the contents of the archive page.
                The RSS feed is particularly tricky, because there is a limited set of tags that it should contain.
                By loading the article's HTML into a DOM parser, and replacing all unsupported tags (like the code viewer web component shown below)
                the HTML can be transformed into something that can be used as RSS feed entry contents.
            </p>
            <p>The core logic of the generator extracts the article's metadata and transforms the HTML:</p>
            <pre><code>customElements.define('blog-generator', class BlogGenerator extends HTMLElement {

    // ...

    async processArticle(article, path) {
        const file = await article.getFile();
        const html = await file.text();
        const dom = (new DOMParser()).parseFromString(html, 'text/html');
        // mandatory
        const title = dom.querySelector('title').textContent;
        const summary = dom.querySelector('meta[name="description"]').getAttribute('content');
        const published = dom.querySelector('blog-header').getAttribute('published');
        const content = await this.processArticleContent(dom.querySelector('main'), path);
        const slug = path.name;
        // optional
        const img = dom.querySelector('blog-header img');
        const image = img &amp;&amp; { src: img.getAttribute('src'), alt: img.getAttribute('alt') };
        const updated = dom.querySelector('blog-header').getAttribute('updated') || undefined;

        this.#articles.push({
            slug, title, summary, content, published, updated, image
        });
    }

    async processArticleContent(main, path) {
        // inline code examples
        await Promise.all([...main.querySelectorAll('x-code-viewer')].map(async (elem) =&gt; {
            const text = await this.downloadFile(elem.getAttribute('src'), path);
            const pre = document.createElement('pre');
            pre.innerHTML = html`&lt;code&gt;${text}&lt;/code&gt;`;
            elem.replaceWith(pre);
        }));

        // convert img src to absolute url
        [...main.querySelectorAll('img')].map((elem) =&gt; {
            const src = elem.getAttribute('src');
            if (src.indexOf('http') !== 0) {
                elem.setAttribute('src', new URL(`articles/${path.name}/${src}`, BLOG_BASE_URL));
            }
        });

        // replace iframes by links
        [...main.querySelectorAll('iframe')].map((elem) =&gt; {
            const src = elem.getAttribute('src');
            const title = elem.getAttribute('title') || src;
            const a = document.createElement('a');
            a.textContent = title;
            const p = document.createElement('p');
            p.appendChild(a);
            elem.replaceWith(p);
            if (src.indexOf('http') !== 0) {
                a.href = new URL(`articles/${path.name}/${src}`, BLOG_BASE_URL);
            } else {
                a.href = src;
            }
        });

        return main.innerHTML;
    }

    // ...

});</code></pre>

            <p>To give you an idea of what <a href="../../generator.html">generator.html</a> looks like in use:</p>
            <img src="https://plainvanillaweb.com/blog/articles/2024-08-17-lets-build-a-blog/generator.webp" alt="generator page screenshot">

            <p>
                The generator JS ended up around 250 lines of code, so not too cumbersome to build or maintain.
                If you're curious about the generator, check out the 
                <a href="https://github.com/jsebrech/plainvanilla/tree/main/public/blog/">blog's code on Github</a>.
                It can be found in <code>generator.html</code> and <code>generator.js</code>.
            </p>

            <p>The user experience of writing a blog post then boils down to this:</p>
            <ol>
                <li>Create an article folder and write the article as HTML</li>
                <li>Open the generator page</li>
                <li>Drop the blog folder on the generator, it will automatically process the articles</li>
                <li>Copy the <code>feed.xml</code> and <code>index.json</code> text to their respective files</li>
                <li>Commit and push the changes</li>
                <li>Optionally: toot on mastodon, add the toot URL in the page, commit and push</li>
            </ol>

            <p>Not too shabby...</p>
        </section>
    ]]></content>
    </entry>
</feed>