<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>Plain Vanilla Blog</title>
    <id>https://plainvanillaweb.com/blog/</id>
    <icon>https://plainvanillaweb.com/favicon.ico</icon>
    <logo>https://plainvanillaweb.com/android-chrome-512x512.png</logo>
    <link rel="alternate" href="https://plainvanillaweb.com/blog/"/>
    <link rel="self" href="https://plainvanillaweb.com/blog/feed.xml"/>
    <updated>2024-09-28T12:00:00.000Z</updated>
    <author>
        <name>Joeri Sebrechts</name>
    </author>
    <entry>
        <title><![CDATA[The unreasonable effectiveness of vanilla JS]]></title>
        <link rel="alternate" type="text/html" href="https://plainvanillaweb.com/blog/articles/2024-09-28-unreasonable-effectiveness-of-vanilla-js/"/>
        <id>https://plainvanillaweb.com/blog/articles/2024-09-28-unreasonable-effectiveness-of-vanilla-js/</id>
        <published>2024-09-28T12:00:00.000Z</published>
        <updated>2024-09-28T12:00:00.000Z</updated>
        <summary><![CDATA[A case study in porting intricate React code to vanilla.]]></summary>
        <media:content url="https://plainvanillaweb.com/blog/articles/2024-09-28-unreasonable-effectiveness-of-vanilla-js/image.webp" type="image/webp" medium="image" />
        <author><name><![CDATA[Joeri Sebrechts]]></name></author>
        <content type="html"><![CDATA[
        <p>
            I have a confession to make. At the end of the Plain Vanilla tutorial's <a href="../../../pages/applications.html">Applications page</a>
            a challenge was posed to the reader: port <a href="https://react.dev">react.dev</a>'s final example 
            <a href="https://react.dev/learn/scaling-up-with-reducer-and-context">Scaling Up with Reducer and Context</a> to vanilla web code.
            Here's the confession: until today I had never actually ported over that example myself.
        </p>
        <p>
            That example demonstrates a cornucopia of React's featureset.
            Richly interactive UI showing a tasks application, making use of a context to lift the task state up,
            and a reducer that the UI's controls dispatch to. React's DOM-diffing algorithm gets a real workout 
            because each task in the list can be edited independently from and concurrently with the other tasks. 
            It is an intricate and impressive demonstration. Here it is in its interactive glory:
        </p>
        <p><a href="https://plainvanillaweb.com/blog/articles/2024-09-28-unreasonable-effectiveness-of-vanilla-js/complete/index.html">complete example</a></p>
        <p>
            But I lied. That interactive example is actually the vanilla version and it is identical.
            If you want to verify that it is in fact identical, check out the <a href="https://codesandbox.io/p/sandbox/react-dev-wy7lfd">original React example</a>.
            And with that out of the way, let's break apart the vanilla code.
        </p>

        <h3>Project setup</h3>

        <p>The React version has these code files that we will need to port:</p>
        <ul>
            <li><strong>public/index.html</strong></li>
            <li><strong>src/styles.css</strong></li>
            <li><strong>src/index.js</strong>: imports the styles, bootstraps React and renders the App component</li>
            <li><strong>src/App.js</strong>: renders the context's TasksProvider containing the AddTask and TaskList components</li>
            <li><strong>src/AddTask.js</strong>: renders the simple form at the top to add a new task</li>
            <li><strong>src/TaskList.js</strong>: renders the list of tasks</li>
        </ul>
        <p>
            To make things fun, I chose the same set of files with the same filenames for the vanilla version.
            Here's <strong>index.html</strong>:
        </p>
        <div><p><em>index.html:</em></p><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;link rel="stylesheet" href="styles.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="root"&gt;&lt;/div&gt;
    &lt;script type="module" src="index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></div>
        <p>
            The only real difference is that it links to <strong>index.js</strong> and <strong>styles.css</strong>.
            The stylesheet was copied verbatim, but for the curious here's a link to <a href="./complete/styles.css">styles.css</a>.
        </p>
        
        <h3>Get to the code</h3>

        <p>
            <strong>index.js</strong> is where it starts to get interesting.
            Compare the React version to the vanilla version:
        </p>
        <div><p><em>index.js (React):</em></p><pre><code>import React, { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./styles.css";

import App from "./App";

const root = createRoot(document.getElementById("root"));
root.render(
  &lt;StrictMode&gt;
    &lt;App /&gt;
  &lt;/StrictMode&gt;
);</code></pre></div>
        <div><p><em>index.js (Vanilla):</em></p><pre><code>import './App.js';
import './AddTask.js';
import './TaskList.js';
import './TasksContext.js';

const render = () =&gt; {
    const root = document.getElementById('root');
    root.append(document.createElement('tasks-app'));
}

document.addEventListener('DOMContentLoaded', render);
</code></pre></div>
        <p>
            Bootstrapping is different but also similar. All of the web components are imported first to load them,
            and then the <code>&lt;tasks-app&gt;</code> component is rendered to the page.
        </p>
        <p>
            The <strong>App.js</strong> code also bears more than a striking resemblance:
        </p>
        <div><p><em>App.js (React):</em></p><pre><code>import AddTask from './AddTask.js';
import TaskList from './TaskList.js';
import { TasksProvider } from './TasksContext.js';

export default function TaskApp() {
  return (
    &lt;TasksProvider&gt;
      &lt;h1&gt;Day off in Kyoto&lt;/h1&gt;
      &lt;AddTask /&gt;
      &lt;TaskList /&gt;
    &lt;/TasksProvider&gt;
  );
}
</code></pre></div>
        <div><p><em>App.js (Vanilla):</em></p><pre><code>customElements.define('tasks-app', class extends HTMLElement {
    connectedCallback() {
        this.innerHTML = `
            &lt;tasks-context&gt;
                &lt;h1&gt;Day off in Kyoto&lt;/h1&gt;
                &lt;task-add&gt;&lt;/task-add&gt;
                &lt;task-list&gt;&lt;/task-list&gt;
            &lt;/tasks-context&gt;
        `;
    }
});
</code></pre></div>

        <p>
            What I like about the code so far is that it <em>feels</em> React-like. I generally find programming against React's API pleasing,
            but I don't like the tooling, page weight and overall complexity baggage that it comes with.
        </p>

        <h3>Adding context</h3>

        <p>
            The broad outline of how to bring a React-like context to a vanilla web application is
            already explained in the <a href="https://plainvanillaweb.com/pages/applications.html#managing-state">passing data deeply section</a> 
            of the main Plain Vanilla tutorial, so I won't cover that again here.
            What adds spice in this specific case is that the React context uses a reducer,
            a function that accepts the old tasks and an action to apply to them, and returns the new tasks to show throughout the application.
        </p>
        <p>
            Thankfully, the React example's reducer function and initial state were already vanilla JS code,
            so those come along for the ride unchanged and ultimately the vanilla context is a very straightforward custom element:
        </p>

        <div><p><em>TasksContext.js (Vanilla):</em></p><pre><code>customElements.define('tasks-context', class extends HTMLElement {
    #tasks = structuredClone(initialTasks);
    get tasks() { return this.#tasks; }
    set tasks(tasks) {
        this.#tasks = tasks;
        this.dispatchEvent(new Event('change'));
    }

    dispatch(action) {
        this.tasks = tasksReducer(this.tasks, action);
    }

    connectedCallback() {
        this.style.display = 'content';
    }
});

function tasksReducer(tasks, action) {
    switch (action.type) {
        case 'added': {
            return [...tasks, {
                id: action.id,
                text: action.text,
                done: false
            }];
        }
        case 'changed': {
            return tasks.map(t =&gt; {
                if (t.id === action.task.id) {
                    return action.task;
                } else {
                    return t;
                }
            });
        }
        case 'deleted': {
            return tasks.filter(t =&gt; t.id !== action.id);
        }
        default: {
            throw Error('Unknown action: ' + action.type);
        }
    }
}

const initialTasks = [
    { id: 0, text: 'Philosopher’s Path', done: true },
    { id: 1, text: 'Visit the temple', done: false },
    { id: 2, text: 'Drink matcha', done: false }
];
</code></pre></div>

        <p>
            The actual context component is very bare bones, as it only needs to store the tasks,
            emit change events for the other components to subscribe to, and provide a dispatch method 
            for those components to call that will use the reducer function to update the tasks.
        </p>

        <h3>Adding tasks</h3>

        <p>
            The AddTask component ends up offering more of a challenge. It's a stateful component with event listeners that dispatches to the reducer:
        </p>
        <div><p><em>AddTask.js (React):</em></p><pre><code>import { useState } from 'react';
import { useTasksDispatch } from './TasksContext.js';

export default function AddTask() {
  const [text, setText] = useState('');
  const dispatch = useTasksDispatch();
  return (
    &lt;&gt;
      &lt;input
        placeholder="Add task"
        value={text}
        onChange={e =&gt; setText(e.target.value)}
      /&gt;
      &lt;button onClick={() =&gt; {
        setText('');
        dispatch({
          type: 'added',
          id: nextId++,
          text: text,
        }); 
      }}&gt;Add&lt;/button&gt;
    &lt;/&gt;
  );
}

let nextId = 3;
</code></pre></div>
        <p>
            The main wrinkle this adds for the vanilla web component is that the event listener on the button element
            cannot be put inline with the markup. Luckily the handling of the input is much simplified
            because we can rely on it keeping its state automatically, a convenience owed to not using a virtual DOM.
            Thanks to the groundwork in the context component the actual dispatching of the action is easy:
        </p>
        <div><p><em>AddTask.js (Vanilla):</em></p><pre><code>customElements.define('task-add', class extends HTMLElement {
    connectedCallback() {
        this.innerHTML = `
            &lt;input type="text" placeholder="Add task" /&gt;
            &lt;button&gt;Add&lt;/button&gt;
        `;
        this.querySelector('button').onclick = () =&gt; {
            const input = this.querySelector('input');
            this.closest('tasks-context').dispatch({
                type: 'added',
                id: nextId++,
                text: input.value
            });
            input.value = '';
        };
    }
})

let nextId = 3;
</code></pre></div>
        <p>
            Fascinating to me is that <strong>index.js</strong>, <strong>App.js</strong>, <strong>TasksContext.js</strong> and <strong>AddTask.js</strong>
            are all fewer lines of code in the vanilla version than their React counterpart while remaining functionally equivalent. 
        </p>

        <h3>Hard mode</h3>
        <p>
            The TaskList component is where React starts really pulling its weight.
            The React version is clean and straightforward and juggles a lot of state with a constantly updating task list UI.
        </p>
        <div><p><em>TaskList.js (React):</em></p><pre><code>import { useState } from 'react';
import { useTasks, useTasksDispatch } from './TasksContext.js';

export default function TaskList() {
  const tasks = useTasks();
  return (
    &lt;ul&gt;
      {tasks.map(task =&gt; (
        &lt;li key={task.id}&gt;
          &lt;Task task={task} /&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

function Task({ task }) {
  const [isEditing, setIsEditing] = useState(false);
  const dispatch = useTasksDispatch();
  let taskContent;
  if (isEditing) {
    taskContent = (
      &lt;&gt;
        &lt;input
          value={task.text}
          onChange={e =&gt; {
            dispatch({
              type: 'changed',
              task: {
                ...task,
                text: e.target.value
              }
            });
          }} /&gt;
        &lt;button onClick={() =&gt; setIsEditing(false)}&gt;
          Save
        &lt;/button&gt;
      &lt;/&gt;
    );
  } else {
    taskContent = (
      &lt;&gt;
        {task.text}
        &lt;button onClick={() =&gt; setIsEditing(true)}&gt;
          Edit
        &lt;/button&gt;
      &lt;/&gt;
    );
  }
  return (
    &lt;label&gt;
      &lt;input
        type="checkbox"
        checked={task.done}
        onChange={e =&gt; {
          dispatch({
            type: 'changed',
            task: {
              ...task,
              done: e.target.checked
            }
          });
        }}
      /&gt;
      {taskContent}
      &lt;button onClick={() =&gt; {
        dispatch({
          type: 'deleted',
          id: task.id
        });
      }}&gt;
        Delete
      &lt;/button&gt;
    &lt;/label&gt;
  );
}
</code></pre></div>

        <p>
            This proved to be a real challenge to port. The vanilla version ended up being a lot more verbose
            because it has to do all the same DOM-reconciliation in explicit logic managed by the <strong>update()</strong> methods
            of <code>&lt;task-list&gt;</code> and <code>&lt;task-item&gt;</code>.
        </p>
        <div><p><em>TaskList.js (Vanilla):</em></p><pre><code>customElements.define('task-list', class extends HTMLElement {
    get context() { return this.closest('tasks-context'); }
    
    connectedCallback() {
        this.context.addEventListener('change', () =&gt; this.update());
        this.append(document.createElement('ul'));
        this.update();
    }

    update() {
        const ul = this.querySelector('ul');
        let before = ul.firstChild;
        this.context.tasks.forEach(task =&gt; {
            let li = ul.querySelector(`:scope &gt; [data-key="${task.id}"]`);
            if (!li) {
                li = document.createElement('li');
                li.dataset.key = task.id;
                li.append(document.createElement('task-item'));
            }
            li.firstChild.task = task;
            // move to the right position in the list if not there yet
            if (li !== before) ul.insertBefore(li, before);
            before = li.nextSibling;
        });
        // remove unknown nodes
        while (before) {
            const remove = before;
            before = before.nextSibling;
            ul.removeChild(remove);
        }
    }
});

customElements.define('task-item', class extends HTMLElement {
    #isEditing = false;
    #task;
    set task(task) { this.#task = task; this.update(); }
    get context() { return this.closest('tasks-context'); }

    connectedCallback() {
        if (this.querySelector('label')) return;
        this.innerHTML = `
            &lt;label&gt;
                &lt;input type="checkbox" /&gt;
                &lt;input type="text" /&gt;
                &lt;span&gt;&lt;/span&gt;
                &lt;button id="edit"&gt;Edit&lt;/button&gt;
                &lt;button id="save"&gt;Save&lt;/button&gt;
                &lt;button id="delete"&gt;Delete&lt;/button&gt;
            &lt;/label&gt;
        `;
        this.querySelector('input[type=checkbox]').onchange = e =&gt; {
            this.context.dispatch({
                type: 'changed',
                task: {
                    ...this.#task,
                    done: e.target.checked
                }
            });
        };
        this.querySelector('input[type=text]').onchange = e =&gt; {
            this.context.dispatch({
                type: 'changed',
                task: {
                    ...this.#task,
                    text: e.target.value
                }
            });
        };
        this.querySelector('button#edit').onclick = () =&gt; {
            this.#isEditing = true;
            this.update();
        };
        this.querySelector('button#save').onclick = () =&gt; {
            this.#isEditing = false;
            this.update();
        };
        this.querySelector('button#delete').onclick = () =&gt; {
            this.context.dispatch({
                type: 'deleted',
                id: this.#task.id
            });
        };
        this.context.addEventListener('change', () =&gt; this.update());
        this.update();
    }

    update() {
        if (this.isConnected &amp;&amp; this.#task) {
            this.querySelector('input[type=checkbox]').checked = this.#task.done;
            const inputEdit = this.querySelector('input[type=text]');
            inputEdit.style.display = this.#isEditing ? 'inline' : 'none';
            inputEdit.value = this.#task.text;
            const span = this.querySelector('span');
            span.style.display = this.#isEditing ? 'none' : 'inline';
            span.textContent = this.#task.text;
            this.querySelector('button#edit').style.display = this.#isEditing ? 'none' : 'inline';
            this.querySelector('button#save').style.display = this.#isEditing ? 'inline' : 'none';
        }
    }
});
</code></pre></div>
        <p>
            Some interesting take-aways:
        </p>
        <ul>
            <li>
                The <code>&lt;task-list&gt;</code> component's <strong>update()</strong> method implements a poor man's version of React reconciliation,
                merging the current state of the <strong>tasks</strong> array into the child nodes of the <code>&lt;ul&gt;</code>.
                In order to do this, it has to store a key on each list item, just like React requires, and here it becomes obvious why that is.
                Without the key we can't find the existing <code>&lt;li&gt;</code> nodes that match up to task items,
                and so would have to recreate the entire list. By adding the key it becomes possible to update the list in-place,
                modifying task items instead of recreating them so that they can keep their on-going edit state.
            </li>
            <li>
                That reconciliation code is very generic however, and it is easy to imagine a fully generic <strong>repeat()</strong>
                function that converts an array of data to markup on the page. In fact, the Lit framework <a href="https://lit.dev/docs/templates/lists/#the-repeat-directive">contains exactly that</a>.
                For brevity's sake this code doesn't go quite that far.
            </li>
            <li>
                The <code>&lt;task-item&gt;</code> component cannot do what the React code does: create different markup depending on the current state.
                Instead it creates the union of the markup across the various states, and then in the <strong>update()</strong>
                shows the right subset of elements based on the current state.
            </li>
        </ul>
        <p>
            That wraps up the entire code. You can find the <a href="https://github.com/jsebrech/vanilla-context-and-reducer">ported example on Github</a>.
        </p>

        <h3>Some thoughts</h3>
        
        <p>
            A peculiar result of this porting challenge is that the vanilla version ends up being roughly 
            the same number of lines of code as the React version. The React code is still overall less verbose (all those querySelectors, oy!),
            but it has its own share of boilerplate that disappears in the vanilla version.
            This isn't a diss against React, it's more of a compliment to how capable browsers have gotten that vanilla web components
            can carry us so far.
        </p>
        <p>
            If I could have waved a magic wand, what would have made the vanilla version simpler?
        </p>
        <ul>
            <li>
                All of those <strong>querySelector</strong> calls get annoying. The alternatives are building the markup easily with innerHTML
                and then fishing out references to the created elements using querySelector, or building the elements one by one verbosely using createElement,
                but then easily having a reference to them. Either of those ends up very verbose. 
                An alternative templating approach that makes it easy to create elements <em>and</em> get a reference to them would be very welcome.
            </li>
            <li>
                As long as we're dreaming, I'm jealous of how easy it is to add the event listeners in JSX.
                A real expression language in HTML templates that supports data and event binding and data-conditional markup would be very neat
                and would take away most of the reason to still find a framework's templating language more convenient.
                Web components are a perfectly fine alternative to React components, they just lack an easy built-in templating mechanism.
            </li>
            <li>
                Browsers could get a little smarter about how they handle DOM updates during event handling.
                In the logic that sorts the <code>&lt;li&gt;</code> to the right order in the list, 
                the <em>if</em> condition before insertBefore proved necessary because the browser
                didn't notice that the element was already placed where it needed to be inserted,
                and click events would get lost as a consequence.
                I've even noticed that assigning a textContent to a button mid-click will make Safari
                lose track of that button's click event. All of that can be worked around with clever reconciliation logic,
                but that's code that belongs in the browser, not in JavaScript.
            </li>
        </ul>
        <p>
            All in all though, I'm really impressed with vanilla JS. I call it unreasonably effective because it is
            jarring just how capable the built-in abilities of browsers are, and just how many web developers despite that 
            still default to web frameworks for every new project. Maybe one day...
        </p>
    ]]></content>
    </entry>
    <entry>
        <title><![CDATA[The life and times of a web component]]></title>
        <link rel="alternate" type="text/html" href="https://plainvanillaweb.com/blog/articles/2024-09-16-life-and-times-of-a-custom-element/"/>
        <id>https://plainvanillaweb.com/blog/articles/2024-09-16-life-and-times-of-a-custom-element/</id>
        <published>2024-09-16T12:00:00.000Z</published>
        <updated>2024-09-16T12:00:00.000Z</updated>
        <summary><![CDATA[The entire lifecycle of a web component, from original creation to when a shadow crosses.]]></summary>
        <media:content url="https://plainvanillaweb.com/blog/articles/2024-09-16-life-and-times-of-a-custom-element/image.webp" type="image/webp" medium="image" />
        <author><name><![CDATA[Joeri Sebrechts]]></name></author>
        <content type="html"><![CDATA[
        <p>
            When first taught about the wave-particle duality of light most people's brains does a double take.
            How can light be two different categories of things at the same time, both a wave and a particle? That's just weird.
            The same thing happens with web components, confusing people when they first try to learn them and run into their Document-JavaScript duality.
            The component systems in frameworks are typically JavaScript-first, only using the DOM as an outlet for their visual appearance.
            Web components however — or custom elements to be precise — can start out in either JavaScript or the document, and are married to neither.
        </p>

        <h3>Just the DOM please</h3>

        <p>
            Do you want to see the minimal JavaScript code needed to set up an <code>&lt;x-example&gt;</code> custom element?
            Here it is:
        </p>
        <p>&nbsp;</p>
        <p>
            No, that's not a typo. Custom elements can be used just fine without any JavaScript.
            Consider this example of an <code>&lt;x-tooltip&gt;</code> custom element that is HTML and CSS only:
        </p>
        <p><a href="https://plainvanillaweb.com/blog/articles/2024-09-16-life-and-times-of-a-custom-element/undefined/example.html">undefined/example.html</a></p>
        <div><p><em>example.html:</em></p><pre><code>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" /&gt;
        &lt;link rel="stylesheet" href="example.css"&gt;
        &lt;title&gt;undefined custom element&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;button&gt;
            Hover me
            &lt;x-tooltip inert role="tooltip"&gt;Thanks for hovering!&lt;/x-tooltip&gt;
        &lt;/button&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre></div>
        <p>
            <small>For the curious, here is the <a href="undefined/example.css">example.css</a>, but it is not important here.</small>
        </p>
        <p>
            Such elements are called <em>undefined custom elements</em>.
            Before custom elements are defined in the window by calling <code>customElements.define()</code> they always start out in this state.
            There is no need to actually define the custom element if it can be solved in a pure CSS way.
            In fact, many "pure CSS" components found online can be solved by such custom elements,
            by styling the element itself and its <code>::before</code> and <code>::after</code> pseudo-elements.
        </p>

        <h3>A question of definition</h3>

        <p>
            The CSS-only representation of the custom element can be progressively enhanced by connecting it up to a JavaScript counterpart,
            a custom element class. This is a class that inherits from <code>HTMLElement</code> and allows the custom element
            to implement its own logic.
        </p>
        <p><a href="https://plainvanillaweb.com/blog/articles/2024-09-16-life-and-times-of-a-custom-element/defined/example.html">defined/example.html</a></p>
        <div><p><em>example.html:</em></p><pre><code>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" /&gt;
        &lt;title&gt;defining the custom element&lt;/title&gt;
        &lt;style&gt;
            body { font-family: system-ui, sans-serif; margin: 1em; }
            x-example {
                background-color: lavender;
            }
            x-example:not(:defined)::after {
                content: '{defined: false}'
            }
            x-example:defined::after {
                content: '{defined: true, status: ' attr(status) '}'
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;Custom element: &lt;x-example&gt;&lt;/x-example&gt;&lt;/p&gt;
        &lt;button onclick="define()"&gt;Define&lt;/button&gt;
        &lt;button onclick="location.reload()"&gt;Reload&lt;/button&gt;

        &lt;script&gt;
            function define() {
                customElements.define('x-example', class extends HTMLElement {
                    constructor() {
                        super();
                    }
                    connectedCallback() {
                        this.setAttribute('status', 'ready');
                    }
                });
            }
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre></div>
        <p>
            What happens to the elements already in the markup at the moment <code>customElements.define()</code>
            is called is an <em>element upgrade</em>. The browser will take all custom elements already in the document,
            and create an instance of the matching custom element class that it connects them to.
            This class enables the element to control its own part of the DOM, but also allows it to react to what happens in the DOM.
        </p>
        <p>
            Element upgrades occur for existing custom elements in the document when <code>customElements.define()</code> is called,
            and for all new custom elements with that tag name created afterwards (e.g. using <code>document.createElement('x-example')</code>).
            It does not occur automatically for detached custom elements (not part of the document) that were created before the element was defined.
            Those can be upgraded retroactively by calling <code>customElements.upgrade()</code>.
        </p>

        <p>
            So far, this is the part of the lifecycle we've seen:
        </p>
        <pre>&lt;undefined&gt; 
    -&gt; define() -&gt; &lt;defined&gt;
    -&gt; automatic upgrade() 
                -&gt; constructor() 
                -&gt; &lt;constructed&gt;
        </pre>

        <p>
            The constructor as shown in the example above is optional, but if it is specified then it has a <a href="https://html.spec.whatwg.org/multipage/custom-elements.html#custom-element-conformance">number of gotcha's</a>:
        </p>
        <dl>
            <dt>It must start with a call to <code>super()</code>.</dt>
            <dt>It should not make DOM changes yet, as the element is not yet guaranteed to be connected to the DOM.</dt>
            <dd>
                This includes reading or modifying its own DOM properties, like its attributes.
                The tricky part is that in the constructor the element might already be in the DOM,
                so setting attributes might work. Or it might give an error. It's best to avoid DOM interaction altogether in the constructor.
            </dd>
            <dt>It should initialize its state, like class properties</dt>
            <dd>
                But work done in the constructor should be minimized and maximally postponed until <code>connectedCallback</code>.
            </dd>
        </dl>

        <h3>Making connections</h3>

        <p>
            After being constructed, if the element was already in the document, its <code>connectedCallback()</code> handler is called.
            This handler is normally called only when the element is inserted into the document, but for elements that are already in the document when they are defined it ends up being called as well.
            In this handler DOM changes can be made, and in the example above the <code>status</code> attribute is set to demonstrate this.
        </p>
        <p>
            The <em>connectedCallback()</em> handler is part of what is known in the HTML standard as <a href="https://html.spec.whatwg.org/multipage/custom-elements.html#custom-element-reactions">custom element reactions</a>:
            These reactions allow the element to respond to various changes to the DOM:
        </p>
        <ul>
            <li><code>connectedCallback()</code> is called when the element is inserted into the document, even if it was only moved from a different place in the same document.</li>
            <li><code>disconnectedCallback()</code> is called when the element is removed from the document.</li>
            <li><code>adoptedCallback()</code> is called when the element is moved to a new document. (You are unlikely to need this in practice.)</li>
            <li><code>attributeChangedCallback()</code> is called when an attribute is changed, but only for the attributes listed in its <code>observedAttributes</code> property.</li>
        </ul>
        <p>
            There are also special reactions for <a href="https://dev.to/stuffbreaker/custom-forms-with-web-components-and-elementinternals-4jaj">form-associated custom elements</a>, 
            but those are a rabbit hole beyond the purview of this blog post.
        </p>
        <p>
            There are more gotcha's to these reactions:
        </p>
        <dl>
            <dt><code>connectedCallback()</code> and <code>disconnectedCallback()</code> can be called multiple times</dt>
            <dd>
                This can occur when the element is moved around in the document.
                These handlers should be written in such a way that it is harmless to run them multiple times,
                e.g. by doing an early exit when it is detected that <em>connectedCallback()</em> was already run.
            </dd>
            <dt><code>attributeChangedCallback()</code> can be called before <code>connectedCallback()</code></dt>
            <dd>
                For all attributes already set when the element in the document is upgraded,
                the <em>attributeChangedCallback()</em> handler will be called first,
                and only after this <em>connectedCallback()</em> is called.
                The unpleasant consequence is that any <em>attributeChangedCallback</em> that tries to update DOM structures
                created in <em>connectedCallback</em> can produce errors.
            </dd>
            <dt><code>attributeChangedCallback()</code> is only called for attribute changes, not property changes.</dt>
            <dd>
                Attribute changes can be done in Javascript by calling <code>element.setAttribute('name', 'value')</code>.
                DOM attributes and class properties can have the same name, but are not automatically linked.
                Generally for this reason it is better to avoid having attributes and properties with the same name.
            </dd>
        </dl>

        <p>
            The lifecycle covered up to this point for elements that start out in the initial document:
        </p>
        <pre>&lt;undefined&gt; 
    -&gt; define() -&gt; &lt;defined&gt;
    -&gt; automatic upgrade() 
                -&gt; [element].constructor()
                -&gt; [element].attributeChangedCallback()
                -&gt; [element].connectedCallback() 
                -&gt; &lt;connected&gt;
        </pre>

        <h3>Flip the script</h3>

        <p>
            So far we've covered one half of the Document-JavaScript duality, for custom elements starting out in the document,
            and only after that becoming defined and gaining a JavaScript counterpart.
            It is however also possible to reverse the flow, and start out from JavaScript.
        </p>
        <p>
            This is the minimal code to create a custom element in JavaScript: <code>document.createElement('x-example')</code>.
            The element does not need to be defined in order to run this code, although it can be, and the resulting node can be inserted into the document
            as if it was part of the original HTML markup.
        </p>
        <p>
            If it is inserted, and after insertion the element becomes defined, then it will behave as described above.
            Things are however different if the element remains detached:
        </p>
        <dl>
            <dt>The detached element will not be automatically upgraded when it is defined.</dt>
            <dd>
                The constructor or reactions will not be called. It will be automatically upgraded when it is inserted into the document.
                It can also be upgraded explicitly by calling <code>customElements.upgrade()</code>.
            </dd>
            <dt>If the detached element is already defined when it is created, it will be upgraded automatically.</dt>
            <dd>The <em>constructor()</em> and <em>attributeChangedCallback()</em> will be called. Because it is not yet part of the document <em>connectedCallback()</em> won't be.</dd>
        </dl>
        <p>
            By now no doubt you are a bit confused. Here's an interactive playground that lets you test
            what happens to elements as they go through their lifecycle, both for those in the initial document and those created dynamically.
        </p>
        <p><a href="https://plainvanillaweb.com/blog/articles/2024-09-16-life-and-times-of-a-custom-element/defined2/example.html">defined2/example.html</a></p>

        <p>Here are some interesting things to try out:</p>
        <ul>
            <li><em>Create</em>, then <em>Define</em>, and you will see that the created element is not upgraded automatically because it is detached from the document.</li>
            <li><em>Create</em>, then <em>Connect</em>, then <em>Define</em>, and you will see that the element is upgraded automatically because it is in the document.</li>
            <li><em>Define</em>, then <em>Create</em>, and you will see that the element is upgraded as soon as it is created (<em>constructed</em> appears in the reactions).</li>
        </ul>
        <p>
            I tried writing a flowchart of all possible paths through the lifecycle that can be seen in this example,
            but it got so unwieldy that I think it's better to just play around with the example until a solid grasp develops.
        </p>

        <h3>In the shadows</h3>

        <p>
            Adding shadow DOM creates yet another wrinkle in the lifecycle.
            At any point in the element's JavaScript half, including in its constructor, a shadow DOM can be attached to the element by calling <code>attachShadow()</code>.
            Because the shadow DOM is immediately available for DOM operations, that makes it possible to do those DOM operations in the constructor.
        </p>
        <p>
            In this next interactive example you can see what happens when the shadow DOM becomes attached.
            The <em>x-shadowed</em> element will immediately attach a shadow DOM in its constructor,
            which happens when the element is upgraded automatically after defining.
            The <em>x-shadowed-later</em> element postpones adding a shadow DOM until a link is clicked,
            so the element first starts out as a non-shadowed custom element, and adds a shadow DOM later.
        </p>

        <p><a href="https://plainvanillaweb.com/blog/articles/2024-09-16-life-and-times-of-a-custom-element/shadowed/example.html">shadowed/example.html</a></p>
        <div><p><em>example.html:</em></p><pre><code>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" /&gt;
        &lt;title&gt;shadowed custom element&lt;/title&gt;
        &lt;style&gt;
            body { font-family: system-ui, sans-serif; margin: 1em; }
            x-shadowed, x-shadowed-later { background-color: lightgray; }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;&amp;lt;x-shadowed&amp;gt;: &lt;x-shadowed&gt;undefined, not shadowed&lt;/x-shadowed&gt;&lt;/p&gt;
        &lt;p&gt;&amp;lt;x-shadowed-later&amp;gt;: &lt;x-shadowed-later&gt;undefined, not shadowed&lt;/x-shadowed-later&gt;&lt;/p&gt;
        &lt;button id="define" onclick="define()"&gt;Define&lt;/button&gt;
        &lt;button onclick="location.reload()"&gt;Reload&lt;/button&gt;

        &lt;script&gt;
        function define() {
            customElements.define('x-shadowed', class extends HTMLElement {
                constructor() {
                    super();
                    this.attachShadow({mode: 'open'});
                    this.shadowRoot.innerHTML = `
                        &lt;span style="background-color: lightgreen"&gt;
                            shadowed
                        &lt;/span&gt;
                    `;
                }
            });
            customElements.define('x-shadowed-later', class extends HTMLElement {
                connectedCallback() {
                    this.innerHTML = 'constructed, &lt;a href="#"&gt;click to shadow&lt;/a&gt;';
                    this.querySelector('a').onclick = (e) =&gt; { e.preventDefault(); this.addShadow() };
                }
                addShadow() {
                    this.attachShadow({mode: 'open'});
                    this.shadowRoot.innerHTML = `
                        &lt;span style="background-color: lightgreen"&gt;
                            shadowed
                        &lt;/span&gt;
                    `;
                }
            });
            document.querySelector('button#define').setAttribute('disabled', true);
        }
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre></div>

        <p>
            While adding a shadow DOM can be done at any point, it is a one-way operation.
            Once added the shadow DOM will replace the element's original contents, and this cannot be undone.
        </p>

        <h3>Keeping an eye out</h3>

        <p>
            So far we've mostly been dealing with initial setup of the custom element,
            but a major part of the lifecycle is responding to changes as they occur.
            Here are some of the major ways that custom elements can respond to DOM changes:
        </p>
        <ul>
            <li><em>connectedCallback</em> and <em>disconnectedCallback</em> to handle DOM insert and remove of the element itself.</li>
            <li><em>attributeChangedCallback</em> to handle attribute changes of the element.</li>
            <li>For shadowed custom elements, the <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement/slotchange_event">slotchange</a> event can be used to detect when children are added and removed in a <code>&lt;slot&gt;</code>.</li>
            <li>Saving the best for last, <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MutationObserver</a> can be used to monitor DOM subtree changes, as well as attribute changes.</li>
        </ul>
        <p>
            <em>MutationObserver</em> in particular is worth exploring, because it is a swiss army knife for monitoring the DOM.
            Here's an example of a counter that automatically updates when new child elements are added:
        </p>
        <p><a href="https://plainvanillaweb.com/blog/articles/2024-09-16-life-and-times-of-a-custom-element/observer/example.html">observer/example.html</a></p>
        <div><p><em>example.html:</em></p><pre><code>&lt;!doctype html&gt;
&lt;html&gt; 
    &lt;head&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" /&gt;
        &lt;title&gt;custom element with observer&lt;/title&gt;
        &lt;style&gt;
            body { font-family: system-ui, sans-serif; margin: 1em; }
            x-wall { display: block; margin-bottom: 1em; }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;x-wall&gt;&lt;x-bottle&gt;&lt;/x-bottle&gt;&lt;/x-wall&gt;
        &lt;button onclick="add()"&gt;Add one more&lt;/button&gt;
        &lt;button onclick="location.reload()"&gt;Reload&lt;/button&gt;

        &lt;script&gt;
        customElements.define('x-wall', class extends HTMLElement {
            connectedCallback() {
                if (this.line) return; // prevent double initialization
                this.line = document.createElement('p');
                this.insertBefore(this.line, this.firstChild);
                new MutationObserver(() =&gt; this.update()).observe(this, { childList: true });
                this.update();
            }
            update() {
                const count = this.querySelectorAll('x-bottle').length;
                this.line.textContent = 
                    `${count} ${count === 1 ? 'bottle' : 'bottles'} of beer on the wall`;
            }
        });
        customElements.define('x-bottle', class extends HTMLElement {
            connectedCallback() { this.textContent = '🍺'; }
        });
        function add() {
            document.querySelector('x-wall').append(
                document.createElement('x-bottle'));
        }
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre></div>

        <p>
            There is still more to tell, but already I can feel eyes glazing over and brains turning to mush,
            so I will keep the rest for another day.
        </p>

        <hr>

        <p>
            Phew, that was a much longer story than I originally set out to write, but custom elements have surprising intricacy.
            I hope you found it useful, and if not at least you got to see some code and click some buttons.
            It's all about the clicking of the buttons.
        </p>
    ]]></content>
    </entry>
    <entry>
        <title><![CDATA[Sweet Suspense]]></title>
        <link rel="alternate" type="text/html" href="https://plainvanillaweb.com/blog/articles/2024-09-09-sweet-suspense/"/>
        <id>https://plainvanillaweb.com/blog/articles/2024-09-09-sweet-suspense/</id>
        <published>2024-09-09T12:00:00.000Z</published>
        <updated>2024-09-09T12:00:00.000Z</updated>
        <summary><![CDATA[React-style lazy loading of web components.]]></summary>
        <media:content url="https://plainvanillaweb.com/blog/articles/2024-09-09-sweet-suspense/image.webp" type="image/webp" medium="image" />
        <author><name><![CDATA[Joeri Sebrechts]]></name></author>
        <content type="html"><![CDATA[
        <p>
            I was reading Addy Osmani and Hassan Djirdeh's book <a href="https://largeapps.dev/">Building Large Scale Web Apps</a>.
            (Which, by the way, I can definitely recommend.) In it they cover all the ways to make a React app sing at scale.
            The chapter on <em>Modularity</em> was especially interesting to me, because JavaScript modules
            are a common approach to modularity in both React and vanilla web code.
        </p>
        <p>
            In that chapter on <em>Modularity</em> there was one particular topic that caught my eye,
            and it was the use of <code>lazy()</code> and <code>Suspense</code>, paired with an <code>ErrorBoundary</code>.
            These are the primitives that React gives us to asynchronously load UI components and their data on-demand while showing a fallback UI,
            and replace the UI with an error message when something goes wrong.
            If you're not familiar, here's a good <a href="https://refine.dev/blog/react-lazy-loading/#catching-loading-errors">overview page</a>.
        </p>
        <p>
            It was at that time that I was visited by the imp of the perverse, which posed to me a simple challenge:
            <em>can you bring React's lazy loading primitives to vanilla web components?</em>
            To be clear, there are <a href="https://css-tricks.com/an-approach-to-lazy-loading-custom-elements/">many</a> 
            <a href="https://github.com/codewithkyle/lazy-loader">ways</a> to 
            <a href="https://www.webcomponents.org/element/st-lazy">load</a> web components 
            <a href="https://lamplightdev.com/blog/2020/03/20/lazy-loading-web-components-with-intersection-observer/">lazily</a>. 
            This is well-trodden territory. What wasn't out there was a straight port of lazy, suspense and error boundary. 
            The idea would not let me go. So here goes nothing.
        </p>

        <h3>Lazy</h3>

        <p>
            The idea and execution of React's lazy is simple. Whenever you want to use a component in your code,
            but you don't want to actually fetch its code yet until it needs to be rendered, wrap it using the <code>lazy()</code> function:<br>
            <code>const MarkdownPreview = lazy(() =&gt; import('./MarkdownPreview.js'));</code><br>
        </p>
        <p>
            React will automatically "suspend" rendering when it first bumps into this lazy component until the component has loaded, and then continue automatically.
        </p>
        <p>
            This works in React because the markup of a component only looks like HTML, 
            but is actually JavaScript in disguise, better known as <em>JSX</em>.
            With web components however, the markup that the component is used in is actually HTML,
            where there is no <code>import()</code> and no calling of functions.
            That means our vanilla <em>lazy</em> cannot be a JavaScript function, but instead it must be an HTML custom element:<br>
            <code>&lt;x-lazy&gt;&lt;x-hello-world&gt;&lt;/x-hello-world&gt;&lt;/x-lazy&gt;</code>
        </p>

        <p>
            The basic setup is simple, when the lazy component is added to the DOM,
            we'll scan for children that have a '-' in the name and therefore are custom elements,
            see if they're not yet defined, and load and define them if so.
            By using <code>display: contents</code> we can avoid having the <code>&lt;x-lazy&gt;</code> impact layout.
        </p>
        <div><p><em>lazy.js:</em></p><pre><code>customElements.define('x-lazy', class extends HTMLElement {
    connectedCallback() {
        this.style.display = 'contents';
        this.#loadLazy();
    }

    #loadLazy() {
        const elements = 
            [...this.children].filter(_ =&gt; _.localName.includes('-'));
        const unregistered = 
            elements.filter(_ =&gt; !customElements.get(_.localName));
        unregistered.forEach(_ =&gt; this.#loadElement(_));
    }

    #loadElement(element) {
        // TODO: load the custom element
    }
});
</code></pre></div>

        <p>
            To actually load the element, we'll have to first find the JS file to import, and then run its register function.
            By having the function that calls <code>customElements.define</code> as the default export by convention the problem is reduced to finding the path to the JS file.
            The following code uses a heuristic that assumes components are in a <code>./components/</code> subfolder of the current document
            and follow a consistent file naming scheme:
        </p>
        <div><p><em>lazy.js (continued):</em></p><pre><code>    #loadElement(element) {
        // strip leading x- off the name
        const cleanName = element.localName.replace(/^x-/, '').toLowerCase();
        // assume component is in its own folder
        const url = `./components/${cleanName}/${cleanName}.js`;
        // dynamically import, then register if not yet registered
        return import(new URL(url, document.location)).then(module =&gt; 
            !customElements.get(element.localName) &amp;&amp; module &amp;&amp; module.default());
    }</code></pre></div>

        <p>
            One could get a lot more creative however, and for example use an 
            <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap">import map</a> 
            to map module names to files. This I leave as an exercise for the reader.
        </p>

        <h3>Suspense</h3>

        <p>
            While the lazy component is loading, we can't show it yet. This is true for custom elements just as much as for React.
            That means we need a wrapper component that will show a fallback UI as long as any components in its subtree are loading,
            the <code>&lt;x-suspense&gt;</code> component. This starts out as a tale of two slots. When the suspense element is loading it shows the fallback, otherwise the content.
        </p>

        <div><p><em>example.html:</em></p><pre><code>&lt;x-suspense&gt;
    &lt;p slot="fallback"&gt;Loading...&lt;/p&gt;
    &lt;x-lazy&gt;&lt;x-hello-world&gt;&lt;/x-hello-world&gt;&lt;/x-lazy&gt;
&lt;/x-suspense&gt;</code></pre></div>
        <div><p><em>suspense.js:</em></p><pre><code>export class Suspense extends HTMLElement {
    #fallbackSlot;
    #contentSlot;

    set loading(isLoading) {
        if (!this.#fallbackSlot) return;
        this.#fallbackSlot.style.display = isLoading ? 'contents' : 'none';
        this.#contentSlot.style.display = !isLoading ? 'contents' : 'none';
    }

    constructor() {
        super();
        this.attachShadow({ mode: 'open' });

        this.#fallbackSlot = document.createElement('slot');
        this.#fallbackSlot.style.display = 'none';
        this.#fallbackSlot.name = 'fallback';
        this.#contentSlot = document.createElement('slot');
        this.shadowRoot.append(this.#fallbackSlot, this.#contentSlot);
    }

    connectedCallback() {
        this.style.display = 'contents';
    }
}
customElements.define('x-suspense', Suspense);</code></pre></div>

        <p>
            The trick now is, how to we get <code>loading = true</code> to happen?
            In Plain Vanilla's applications page I showed how a React context can be simulated using the <code>element.closest()</code> API.
            We can use the same mechanism to create a generic API that will let our suspense wait on a promise to complete.
        </p>

        <div><p><em>suspense.js (continued):</em></p><pre><code>    static waitFor(sender, ...promises) {
        const suspense = sender.closest('x-suspense');
        if (suspense) suspense.addPromises(...promises);
    }

    addPromises(...promises) {
        if (!promises.length) return;
        this.loading = true;
        // combine into previous promises if there are any
        const newPromise = this.#waitingForPromise = 
            Promise.allSettled([...promises, this.#waitingForPromise]);
        // wait for all promises to complete
        newPromise.then(_ =&gt; {
            // if no newer promises were added, we're done
            if (newPromise === this.#waitingForPromise) {
                this.loading = false;
            }
        });
    }</code></pre></div>

        <p>
            <code>Suspense.waitFor</code> will call the nearest ancestor <code>&lt;x-suspense&gt;</code>
            to a given element, and give it a set of promises that it should wait on.
            This API can then be called from our <code>&lt;x-lazy&gt;</code> component.
            Note that <code>#loadElement</code> returns a promise that completes when the custom element is loaded or fails to load.
        </p>
        <div><p><em>lazy.js (continued):</em></p><pre><code>    #loadLazy() {
        const elements = 
            [...this.children].filter(_ =&gt; _.localName.includes('-'));
        const unregistered = 
            elements.filter(_ =&gt; !customElements.get(_.localName));
        if (unregistered.length) {
            Suspense.waitFor(this, 
                ...unregistered.map(_ =&gt; this.#loadElement(_))
            );
        }
    }</code></pre></div>
        <p>
            The nice thing about the promise-based approach is that we can give it any promise, just like we would with React's suspense.
            For example, when loading data in a custom element that is in the suspense's subtree, we can call the exact same API:<br>
            <code>Suspense.waitFor(this, fetch(url).then(...))</code>
        </p>

        <h3>Error boundary</h3>

        <p>
            Up to this point, we've been assuming everything always works. This is <del>Sparta</del>software, it will never "always work".
            What we need is a graceful way to intercept failed promises that are monitored by the suspense,
            and show an error message instead. That is the role that React's error boundary plays.
        </p>
        <p>
            The approach is similar to suspense:
        </p>
        <div><p><em>example.html:</em></p><pre><code>&lt;x-error-boundary&gt;
    &lt;p slot="error"&gt;Something went wrong&lt;/p&gt;
    &lt;x-suspense&gt;
        &lt;p slot="fallback"&gt;Loading...&lt;/p&gt;
        &lt;x-lazy&gt;&lt;x-hello-world&gt;&lt;/x-hello-world&gt;&lt;/x-lazy&gt;
    &lt;/x-suspense&gt;
&lt;/x-error-boundary&gt;</code></pre></div>
        <p>
            And the code is also quite similar to suspense:
        </p>
        <div><pre><code>export class ErrorBoundary extends HTMLElement {

    static showError(sender, error) {
        if (!error) throw new Error('ErrorBoundary.showError: expected two arguments but got one');
        const boundary = sender.closest('x-error-boundary');
        if (boundary) {
            boundary.error = error;
        } else {
            console.error('unable to find x-error-boundary to show error');
            console.error(error);
        }
    }

    #error;
    #errorSlot;
    #contentSlot;

    get error() {
        return this.#error;
    }

    set error(error) {
        if (!this.#errorSlot) return;
        this.#error = error;
        this.#errorSlot.style.display = error ? 'contents' : 'none';
        this.#contentSlot.style.display = !error ? 'contents' : 'none';
        if (error) {
            this.#errorSlot.assignedElements().forEach(element =&gt; {
                if (Object.hasOwn(element, 'error')) {
                    element.error = error;
                } else {
                    element.setAttribute('error', error?.message || error);
                }
            });
            this.dispatchEvent(new CustomEvent('error', { detail: error }));
        }
    }

    constructor() {
        super();
        this.attachShadow({ mode: 'open' });

        this.#errorSlot = document.createElement('slot');
        this.#errorSlot.style.display = 'none';
        this.#errorSlot.name = 'error';
        // default error message
        this.#errorSlot.textContent = 'Something went wrong.';
        this.#contentSlot = document.createElement('slot');
        this.shadowRoot.append(this.#errorSlot, this.#contentSlot);
    }

    reset() {
        this.error = null;
    }

    connectedCallback() {
        this.style.display = 'contents';
    }
}
customElements.define('x-error-boundary', ErrorBoundary);
</code></pre></div>

        <p>
            Similar to suspense, this has an API <code>ErrorBoundary.showError()</code> that can be called
            from anywhere inside the error boundary's subtree to show an error that occurs.
            The suspense component is then modified to call this API when it bumps into a rejected promise.
            To hide the error, the <code>reset()</code> method can be called on the error boundary element.
        </p>
        <p>
            Finally, the <code>error</code> setter will set the error as a property or attribute
            on all children in the error slot, which enables customizing the error message's behavior based on the error object's properties
            by creating a custom <code>&lt;x-error-message&gt;</code> component.
        </p>

        <h3>Conclusion</h3>

        <p>
            Finally, we can bring all of this together in a single example,
            that combines lazy, suspense, error boundary, a customized error message, and a lazy-loaded hello-world component.
        </p>

        <div><p><em>example/index.js:</em></p><pre><code>import { registerLazy } from './components/lazy.js';
import { registerSuspense } from './components/suspense.js';
import { registerErrorBoundary } from './components/error-boundary.js';
import { registerErrorMessage } from './components/error-message.js';

customElements.define('x-demo', class extends HTMLElement {

    constructor() {
        super();
        registerLazy();
        registerSuspense();
        registerErrorBoundary();
        registerErrorMessage();
    }

    connectedCallback() {
        this.innerHTML = `
            &lt;p&gt;Lazy loading demo&lt;/p&gt;
            &lt;button id="lazy-load"&gt;Load lazy&lt;/button&gt;
            &lt;button id="error-reset" disabled&gt;Reset error&lt;/button&gt;
            &lt;div id="lazy-load-div"&gt;
                &lt;p&gt;Click to load..&lt;/p&gt;
            &lt;/div&gt;
        `;
        const resetBtn = this.querySelector('button#error-reset')
        resetBtn.onclick = () =&gt; {
            this.querySelector('x-error-boundary').reset();
            resetBtn.setAttribute('disabled', true);
        };
        const loadBtn = this.querySelector('button#lazy-load');
        loadBtn.onclick = () =&gt; {
            this.querySelector('div#lazy-load-div').innerHTML = `
                &lt;x-error-boundary&gt;
                    &lt;x-error-message slot="error"&gt;&lt;/x-error-message&gt;
                    &lt;x-suspense&gt;
                        &lt;p slot="fallback"&gt;Loading...&lt;/p&gt;
                        &lt;p&gt;&lt;x-lazy&gt;&lt;x-hello-world&gt;&lt;/x-hello-world&gt;&lt;/x-lazy&gt;&lt;/p&gt;
                    &lt;/x-suspense&gt;
                &lt;/x-error-boundary&gt;
            `
            this.querySelector('x-error-boundary').addEventListener('error', _ =&gt; {
                resetBtn.removeAttribute('disabled');
            });
            loadBtn.setAttribute('disabled', true);
        };
    }

});
</code></pre></div>
        <p><a href="https://plainvanillaweb.com/blog/articles/2024-09-09-sweet-suspense/example/index.html">complete example</a></p>

        <p>
            For the complete example's code, as well as the lazy, suspense and error-boundary components,
            check out the <a href="https://github.com/jsebrech/sweet-suspense">sweet-suspense repo on Github</a>.
        </p>
    ]]></content>
    </entry>
    <entry>
        <title><![CDATA[How fast are web components?]]></title>
        <link rel="alternate" type="text/html" href="https://plainvanillaweb.com/blog/articles/2024-09-06-how-fast-are-web-components/"/>
        <id>https://plainvanillaweb.com/blog/articles/2024-09-06-how-fast-are-web-components/</id>
        <published>2024-09-06T12:00:00.000Z</published>
        <updated>2024-09-15T12:00:00.000Z</updated>
        <summary><![CDATA[Benchmarking the relative performance of different web component techniques.]]></summary>
        <media:content url="https://plainvanillaweb.com/blog/articles/2024-09-06-how-fast-are-web-components/image.webp" type="image/webp" medium="image" />
        <author><name><![CDATA[Joeri Sebrechts]]></name></author>
        <content type="html"><![CDATA[
        <aside>
            <h3>Author's note</h3>
            <p>
                This article initially had somewhat different results and conclusions,
                but deficiencies in the original benchmark were pointed out and addressed.
                Where the conclusions were changed from the original article, this is pointed out in the text.
            </p>
        </aside>

        <p>
            It is often said that web components are slow.
            This was also my experience when I first tried building web components a few years ago.
            At the time I was using the Stencil framework, because I didn't feel confident that they could be built well without a framework.
            Performance when putting hundreds of them on a page was so bad that I ended up going back to React.
        </p>
        <p>
            But as I've gotten deeper into vanilla web development I started to realize that maybe I was just using it wrong.
            Perhaps web components can be fast, if built in a light-weight way.
            This article is an attempt to settle the question "How fast are web components?".
        </p>

        <h3>The lay of the land</h3>

        <p>
            What kinds of questions did I want answered?
        </p>
        <ul>
            <li>How many web components can you render on the page in a millisecond?</li>
            <li>Does the technique used to built the web component matter, which technique is fastest?</li>
            <li>How do web component frameworks compare? I used Lit as the framework of choice as it is well-respected.</li>
            <li>How does React compare?</li>
            <li>What happens when you combine React with web components?</li>
        </ul>

        <p>
            To figure out the answer I made a benchmark as a vanilla web page (of course),
            that renders thousands of very simple components containing only <code>&lt;span&gt;.&lt;/span&gt;</code>
            and measured the elapsed time. This benchmark was then run on multiple devices and multiple browsers
            to figure out performance characteristics. The ultimate goal of this test is to figure out the absolute best performance
            that can be extracted from the most minimal web component.
        </p>

        <p>To get a performance range I used two devices for testing:</p>
        <ul>
            <li>A <em>Macbook Air M1</em> running MacOS, to stand in as the "fast" device, comparable to a new high end iPhone.</li>
            <li>An <em>Asus Chi T300 Core M</em> from 2015 running Linux Mint Cinnamon, to stand in as the "slow" device, comparable to an older low end Android.</li>
        </ul>
        <p>Between these devices is a 7x CPU performance gap.</p>

        <h3>The test</h3>

        <p>
            The test is simple: render thousands of components using a specific technique, 
            call <code>requestAnimationFrame()</code> repeatedly until they actually render,
            then measure elapsed time. This produces a <em>components per millisecond</em> number.
        </p>
        <p>The techniques being compared:</p>
        <ul>
            <li><strong>innerHTML:</strong> each web component renders its content by assigning to <code>this.innerHTML</code></li>
            <li><strong>append:</strong> each web component creates the span using <code>document.createElement</code> and then appends it to itself</li>
            <li><strong>append (buffered):</strong> same as the append method, except all web components are first buffered to a document fragment which is then appended to the DOM</li>
            <li><strong>shadow + innerHTML:</strong> the same as innerHTML, except each component has a shadow DOM</li>
            <li><strong>shadow + append:</strong> the same as append, except each component has a shadow DOM</li>
            <li><strong>template + append:</strong> each web component renders its content by cloning a template and appending it</li>
            <li><strong>textcontent:</strong> each web component directly sets its textContent property, instead of adding a span (making the component itself be the span)
            </li><li><strong>direct:</strong> appends spans instead of custom elements, to be able to measure custom element overhead</li>
            <li><strong>lit:</strong> each web component is rendered using the lit framework, in the way that its documentation recommends</li>
            <li><strong>react pure:</strong> rendering in React as a standard React component, to have a baseline for comparison to mainstream web development</li>
            <li><strong>react + wc:</strong> each React component wraps the append-style web component</li>
            <li><strong>(norender):</strong> same as other strategies, except the component is only created but not added to the DOM, to separate out component construction cost</li>
        </ul>
        <p>
            This test was run on M1 in Brave, Chrome, Edge, Firefox and Safari. And on Chi in Chrome and Firefox.
            It was run for 10 iterations and a geometric mean was taken of the results.
        </p>

        <h3>The results</h3>

        <p>First, let's compare techniques. The number here is components per millisecond, so <strong>higher is better</strong>.</p>
        
        <p><strong>Author's note:</strong> the numbers from the previous version of this article are <del>crossed out</del>.</p>
        <table>
            <thead>
                <tr><th colspan="2">Chrome on M1</th></tr>
                <tr><th>technique</th><th>components/ms</th></tr>
            </thead>
            <tbody>
                <tr><td>innerHTML</td><td><del>143</del> 135</td></tr>
                <tr><td>append</td><td><del>233</del> 239</td></tr>
                <tr><td>append (buffered)</td><td><del>228</del> 239</td></tr>
                <tr><td>shadow + innerHTML</td><td><del>132</del> 127</td></tr>
                <tr><td>shadow + append</td><td><del>183</del> 203</td></tr>
                <tr><td>template + append</td><td><del>181</del> 198</td></tr>
                <tr><td>textcontent</td><td>345</td></tr>
                <tr><td>direct</td><td>461</td></tr>
                <tr><td>lit</td><td><del>133</del> 137</td></tr>
                <tr><td>react pure</td><td><del>275</del> 338</td></tr>
                <tr><td>react + wc</td><td><del>172</del> 212</td></tr>
                <tr><td>append (norender)</td><td>1393</td></tr>
                <tr><td>shadow (norender)</td><td>814</td></tr>
                <tr><td>direct (norender)</td><td>4277</td></tr>
                <tr><td>lit (norender)</td><td>880</td></tr>
            </tbody>
        </table>

        <table>
            <thead>
                <tr><th colspan="2">Chrome on Chi, best of three</th></tr>
                <tr><th>technique</th><th>components/ms</th></tr>
            </thead>
            <tbody>
                <tr><td>innerHTML</td><td><del>25</del> 29</td></tr>
                <tr><td>append</td><td><del>55</del> 55</td></tr>
                <tr><td>append (buffered)</td><td><del>56</del> 59</td></tr>
                <tr><td>shadow + innerHTML</td><td><del>24</del> 26</td></tr>
                <tr><td>shadow + append</td><td><del>36</del> 47</td></tr>
                <tr><td>template + append</td><td><del>45</del> 46</td></tr>
                <tr><td>textcontent</td><td>81</td></tr>
                <tr><td>direct</td><td>116</td></tr>
                <tr><td>lit</td><td><del>30</del> 33</td></tr>
                <tr><td>react pure</td><td><del>77</del> 87</td></tr>
                <tr><td>react + wc</td><td><del>45</del> 52</td></tr>
                <tr><td>append (norender)</td><td>434</td></tr>
                <tr><td>shadow (norender)</td><td>231</td></tr>
                <tr><td>direct (norender)</td><td>1290</td></tr>
                <tr><td>lit (norender)</td><td>239</td></tr>
            </tbody>
        </table>

        <p>
            One relief right off the bat is that even the slowest implementation on the slow device renders 100.000 components in 4 seconds.
            React is roughly in the same performance class as well-written web components.
            That means for a typical web app performance is not a reason to avoid web components.
        </p>
        <aside>
            <h3>Author's note</h3>
            <p>
                The previous version of this article said React was faster than web components,
                but this only the case if we make the web components render a span. Unlike a React component a web component
                is itself part of the DOM, and so is itself the equivalent of a span. The <em>textcontent</em> strategy exploits this advantage
                to functionally do the same as the React code, and it matches its performance.
            </p>
        </aside>

        <p>
            As far as web component technique goes, the performance delta between the fastest and the slowest technique is around 2x,
            so again for a typical web app that difference will not matter. Things that slow down web components
            are shadow DOM and innerHTML. Appending directly created elements or cloned templates and avoiding shadow DOM is the right strategy
            for a well-performing web component that needs to end up on the page thousands of times.
        </p>

        <p>
            On the slow device the Lit framework is a weak performer, probably due to its use of shadow DOM and JS-heavy approaches.
            Meanwhile, pure React is the best performer, because while it does more work in creating the virtual DOM and diffing it to the real DOM,
            it benefits from not having to initialize the web component class instances.
            Consequently, when wrapping web components inside React components we see React's performance advantage disappear, and that it adds a performance tax.
            In the grand scheme of things however, the differences between React and optimized web components remains small.
        </p>

        <p>
            The fast device is up to 5x faster than the slow device in Chrome, depending on the technique used,
            so it is really worth testing applications on slow devices to get an idea of the range of performance.
        </p>

        <p>
            Next, let's compare browsers:
        </p>

        <table>
            <thead>
                <tr><th colspan="2">M1, append, best of three</th></tr>
                <tr><th>browser</th><th>components/ms</th></tr>
            </thead>
            <tbody>
                <tr><td>Brave</td><td><del>146</del> 145</td></tr>
                <tr><td>Chrome</td><td><del>233</del> 239</td></tr>
                <tr><td>Edge</td><td><del>224</del> 237</td></tr>
                <tr><td>Firefox</td><td><del>232</del> 299</td></tr>
                <tr><td>Safari</td><td><del>260</del> 239</td></tr>
            </tbody>
        </table>

        <table>
            <thead>
                <tr><th colspan="2">Chi, append, best of three</th></tr>
                <tr><th>browser</th><th>components/ms</th></tr>
            </thead>
            <tbody>
                <tr><td>Chrome</td><td><del>55</del> 55</td></tr>
                <tr><td>Firefox</td><td><del>180</del> 77</td></tr>
            </tbody>
        </table>

        <p>
            Brave is really slow, probably because of its built-in ad blocking. Ad blocking extensions also slow down the other browsers by a lot.
            Safari, Chrome and Edge end up in roughly the same performance bucket. Firefox is the best performer overall.
            Using the "wrong" browser can halve the performance of a machine.
        </p>
        <p>
            <strong>Author's note:</strong>
            due to a measurement error in measuring elapsed time, the previous version of this article had Safari as fastest and Firefox as middle of the pack.
        </p>
        <p>
            There is a large performance gap when you compare the slowest technique on the slowest browser on the slowest device,
            with its fastest opposite combo. Specifically, there is a 16x performance gap:
        </p>
        <ul>
            <li>textContent, Firefox on M1: 430 components/ms</li>
            <li>Shadow DOM + innerHTML, Chrome on Chi: 26 components/ms</li>
        </ul>
        <p>
            That means it becomes worthwhile to carefully consider technique when having to support a wide range of browsers and devices,
            because a bad combination may lead to a meaningfully degraded user experience.
            And of course, you should always test your web app on a slow device to make sure it still works ok.
        </p>
        
        <h3>Bottom line</h3>

        <p>
            I feel confident now that web components can be fast enough for almost all use cases where someone might consider React instead.
        </p>
        <p>
            However, it does matter how they are built. Shadow DOM should not be used for smaller often used web components,
            and the contents of those smaller components should be built using append operations instead of innerHTML.
            The use of web component frameworks might impact their performance significantly,
            and given how easy it is to write vanilla web components I personally don't see the point behind Lit or Stencil. YMMV.
        </p>

        <p>
            The full benchmark code and results can be <a href="https://github.com/jsebrech/vanilla-benchmarks">found on Github</a>.
        </p>

    ]]></content>
    </entry>
    <entry>
        <title><![CDATA[A unix philosophy for web development]]></title>
        <link rel="alternate" type="text/html" href="https://plainvanillaweb.com/blog/articles/2024-09-03-unix-philosophy/"/>
        <id>https://plainvanillaweb.com/blog/articles/2024-09-03-unix-philosophy/</id>
        <published>2024-09-03T12:00:00.000Z</published>
        <updated>2024-09-03T12:00:00.000Z</updated>
        <summary><![CDATA[Maybe all web components need to be a light-weight framework is the right set of helper functions.]]></summary>
        <media:content url="https://plainvanillaweb.com/blog/articles/2024-09-03-unix-philosophy/image.webp" type="image/webp" medium="image" />
        <author><name><![CDATA[Joeri Sebrechts]]></name></author>
        <content type="html"><![CDATA[
        <p>
            Web components have their malcontents. While frameworks have done their best to provide
            a place for web components to fit into their architecture, the suit never fits quite right,
            and framework authors have not been shy about expressing their disappointment.
            Here's Ryan Carniato of SolidJS explaining what's wrong with web components:
        </p>
        <blockquote>
            The collection of standards (Custom Elements, HTML Templates, Shadow DOM, and formerly HTML Imports) 
            put together to form Web Components on the surface seem like they could be used to replace 
            your favourite library or framework. But they are not an advanced templating solution. 
            They don't improve your ability to render or update the DOM. 
            They don't manage higher-level concerns for you like state management.
        </blockquote>
        <cite><a href="https://dev.to/ryansolid/maybe-web-components-are-not-the-future-hfh">Ryan Carniato</a></cite>
        <p>
            While this criticism is true, perhaps it's besides the point.
            Maybe web components were never meant to solve those problems anyway.
            Maybe there are ways to solve those problems in a way that dovetails with web components as they exist.
            In the main <a href="../../../pages/components.html">components tutorial</a> I've already explained what they <em>can</em> do,
            now let's see what can be done about the things that they <em>can't</em> do.
        </p>

        <h3>The Unix Philosophy</h3>

        <p>
            The Unix operating system carries with it a culture and philosophy of system design,
            which carries over to the command lines of today's Unix-like systems like Linux and MacOS. 
            This philosophy can be summarized as follows:
        </p>
        <ul>
            <li>Write programs that do one thing and do it well.</li>
            <li>Write programs to work together.</li>
            <li>Write programs to handle text streams, because that is a universal interface.</li>
        </ul>
        <p>
            What if we look at the various technologies that comprise web components as just programs, 
            part of a Unix-like system of web development that we collectively call the browser platform?
            In that system we can do better than text and use the DOM as the universal interface between programs, 
            and we can extend the system with a set of single purpose independent "programs" (functions) 
            that fully embrace the DOM by augmenting it instead of replacing it.
        </p>
        <p>
            In a sense this is the most old-school way of building web projects, the one people who "don't know any better"
            automatically gravitate to. What us old-school web developers did before Vue and Solid and Svelte, before Angular and React,
            before Knockout and Ember and Backbone, before even jQuery, was have a bunch of functions in <code>utilities.js</code>
            that we copied along from project to project.
            But, you know, sometimes old things can become new again.
        </p>
        <p>
            In previous posts I've already covered a <code>html()</code> function for <a href="../2024-08-25-vanilla-entity-encoding/">vanilla entity encoding</a>,
            and a <code>signal()</code> function that provides a <a href="../2024-08-30-poor-mans-signals/">tiny signals</a> implementation 
            that can serve as a lightweight system for state management.
            That still leaves a missing link between the state managed by the signals and the DOM that is rendered from safely entity-encoded HTML.
            What we need is a <code>bind()</code> function that can bind data to DOM elements and bind DOM events back to data.
        </p>

        <h3>Finding inspiration</h3>

        <p>
            In order to bind a template to data, we need a way of describing that behavior in the HTML markup.
            Well-trodden paths are often the best starting place to look for inspiration. I like <a href="https://vuejs.org/guide/essentials/template-syntax.html">Vue's template syntax</a>,
            because it is valid HTML but just augmented, and because it is proven. Vue's templates only pretend to be HTML
            because they're actually compiled to JavaScript behind the scenes, but let's start there as an API.
            This is what it looks like:
        </p>
        <dl>
            <dt><code>&lt;img :src="imageSrc" /&gt;</code></dt>
            <dd>Bind <em>src</em> to track the value of the <em>imageSrc</em> property of the current component.
                Vue is smart enough to set a property if one exists, and falls back to setting an attribute otherwise.
                (If that confuses you, read about <a href="https://javascript.info/dom-attributes-and-properties">attributes and properties</a> first.)</dd>
            <dt><code>&lt;button @click="doThis"&gt;&lt;/button&gt;</code></dt>
            <dd>Bind the <em>click</em> event to the <em>doThis</em> method of the current component.</dd>
        </dl>
        <p>
            By chance I came across this article about <a href="https://hawkticehurst.com/2024/05/bring-your-own-base-class/">making a web component base class</a>.
            In the section <em>Declarative interactivity</em> the author shows a way to do the Vue-like event binding syntax
            on a vanilla web component. This is what inspired me to develop the concept into a generic binding function and write this article.
        </p>

        <h3>Just an iterator</h3>

        <p>
            The heart of the binding function is an HTML fragment iterator. 
            After all, before we can bind attributes we need to first find the ones that have binding directives.
        </p>
        <div><pre><code>export const bind = (template) =&gt; {
    const fragment = template.content.cloneNode(true);
    // iterate over all nodes in the fragment
    const iterator = document.createNodeIterator(
        fragment,
        NodeFilter.SHOW_ELEMENT,
        {
            // reject any node that is not an HTML element
            acceptNode: (node) =&gt; {
                if (!(node instanceof HTMLElement))
                    return NodeFilter.FILTER_REJECT;
                return NodeFilter.FILTER_ACCEPT;
            },
        }
    );
    let node;
    while (node = iterator.nextNode()) {
        if (!node) return;
        const elem = node;
        for (const attr of Array(...node.attributes)) {
            // check for event binding directive
            if (attr.name.startsWith('@')) {

                // TODO: bind event ...
                
                elem.removeAttributeNode(attr);
            // check for property/attribute binding directive
            } else if (attr.name.startsWith(':')) {
                
                // TODO: bind data ...
                
                elem.removeAttributeNode(attr);
            }
        }
    }
    return fragment;
}</code></pre></div>
        <p>
            This code will take an <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template">HTML template element</a>, 
            clone it to a <a href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment">document fragment</a>, 
            and then iterate over all the nodes in the fragment, discovering their attributes. 
            Then for each attribute a check is made to see if it's a binding directive (@ or :). 
            The node is then bound to data according to the directive attribute (shown here as TODO's), 
            and the attribute is removed from the node. At the end the bound fragment is returned for inserting into the DOM.
        </p>
        <p>
            The benefit of using a fragment is that it is disconnected from the main DOM, while still offering all of the DOM API's. 
            That means we can easily create a node iterator to walk over it and discover all the attributes 
            with binding directives, modify those nodes and attributes in-place, and still be sure we're not causing 
            DOM updates in the main page until the fragment is inserted there. This makes the bind function very fast.
        </p>
        <p>
            If you're thinking "woah dude, that's a lot of code and a lot of technobabble, I ain't reading all that,"
            then please, I implore you to read through the code line by line, and you'll see it will all make sense.
        </p>
        <p>
            Of course, we also need to have something to bind <em>to</em>, so we need to add a second parameter.
            At the same time, it would be nice to just be able to pass in a string and have it auto-converted into a template.
            The beginning of our bind function then ends up looking like this:
        </p>
        <div><pre><code>export const bind = (template, target) =&gt; {
    if (!template.content) {
        const text = template;
        template = document.createElement('template');
        template.innerHTML = text;
    }
    const fragment = template.content.cloneNode(true);
// ...
}</code></pre></div>
        <p>That just leaves us the TODO's. We can make those as simple or complicated as we want. I'll pick a middle ground.</p>

        <h3>Binding to events</h3>

        <p>This 20 line handler binds events to methods, signals or properties:</p>
        <div><pre><code>// check for custom event listener attributes
if (attr.name.startsWith('@')) {
    const event = attr.name.slice(1);
    const property = attr.value;
    let listener;
    // if we're binding the event to a function, call it directly
    if (typeof target[property] === 'function') {
        listener = target[property].bind(target);
    // if we're binding to a signal, set the signal's value
    } else if (typeof target[property] === 'object' &amp;&amp; 
                typeof target[property].value !== 'undefined') {
        listener = e =&gt; target[property].value = e.target.value;
    // fallback: assume we're binding to a property, set the property's value
    } else {
        listener = e =&gt; target[property] = e.target.value;
    }
    elem.addEventListener(event, listener);
    // remove (non-standard) attribute from element
    elem.removeAttributeNode(attr);
}</code></pre></div>

        <p>That probably doesn't explain much, so let me give an example of what this enables:</p>
        <p><a href="https://plainvanillaweb.com/blog/articles/2024-09-03-unix-philosophy/example-bind3/example.html">Binding to events example</a></p>
        <div><pre><code>import { bind } from './bind.js';
import { signal } from './signals.js';

customElements.define('x-example', class Example extends HTMLElement {

    set a(value) { 
        this.setAttribute('a', value);
        this.querySelector('label[for=a] span').textContent = value;
    }
    set b(value) {
        this.setAttribute('b', value);
        this.querySelector('label[for=b] span').textContent = value;
    }
    c = signal('');

    connectedCallback() {
        this.append(bind(`
            &lt;div&gt;
                &lt;input id="a" type="number" @input="onInputA"&gt;
                &lt;label for="a"&gt;A = &lt;span&gt;&lt;/span&gt;&lt;/label&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;input id="b" type="number" @input="b"&gt;
                &lt;label for="b"&gt;B = &lt;span&gt;&lt;/span&gt;&lt;/label&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;input id="c" type="number" @input="c"&gt;
                &lt;label for="c"&gt;C = &lt;span&gt;&lt;/span&gt;&lt;/label&gt;
            &lt;/div&gt;
            &lt;button @click="onClick"&gt;Add&lt;/button&gt;
            &lt;div&gt;Result: &lt;span id="result"&gt;&lt;/span&gt;&lt;/div&gt;
        `, this));
        this.c.effect(() =&gt; 
            this.querySelector('label[for=c] span').textContent = this.c);
    }

    onInputA (e) {
        this.a = e.target.value;
    }

    onClick() {
        this.querySelector('#result').textContent =
            +this.getAttribute('a') + +this.getAttribute('b') + +this.c;
    }
});
</code></pre></div>

        <ul>
            <li><code>input#a</code>'s input event is handled by calling the <code>onClickA()</code> method.</li>
            <li><code>input#b</code>'s input event is handled by assigning <code>e.target.value</code> to the <code>b</code> property.</li>
            <li><code>input#c</code>'s input event is handled by setting the value of the <code>c</code> signal.</li>
        </ul>
        <p>
            If you're not familiar with the <code>signal()</code> function, check out the <a href="../2024-08-30-poor-mans-signals/">tiny signals</a> 
            implementation in the previous post. For now you can also just roll with it.
        </p>
        <p>Not a bad result for 20 lines of code.</p>

        <h3>Binding to data</h3>
        <p>
            Having established the pattern for events that automatically update properties, 
            we now reverse the polarity to make data values automatically set element properties or attributes.
        </p>
        <div><pre><code>// ...
    if (attr.name.startsWith(':')) {
        // extract the name and value of the attribute/property
        let name = attr.name.slice(1);
        const property = getPropertyForAttribute(name, target);
        const setter = property ?
            () =&gt; elem[property] = target[attr.value] :
            () =&gt; elem.setAttribute(name, target[attr.value]);
        setter();
        // if we're binding to a signal, listen to updates
        if (target[attr.value]?.effect) {
            target[attr.value].effect(setter);
        // if we're binding to a property, listen to the target's updates
        } else if (target.addEventListener) {
            target.addEventListener('change', setter);
        }
        // remove (non-standard) attribute from element
        elem.removeAttributeNode(attr);
    }
// ...

function getPropertyForAttribute(name, obj) {
    switch (name.toLowerCase()) {
        case 'text': case 'textcontent':
            return 'textContent';
        case 'html': case 'innerhtml':
            return 'innerHTML';
        default:
            for (let prop of Object.getOwnPropertyNames(obj)) {
                if (prop.toLowerCase() === name.toLowerCase()) {
                    return prop;
                }
            }   
    }
}</code></pre></div>
        <p>
            The <code>getPropertyForAttribute</code> function is necessary because the attributes that contain the directives
            will have names that are case-insensitive, and these must be mapped to property names that are case-sensitive.
            Also, the <code>:text</code> and <code>:html</code> shorthand notations replace the role of <code>v-text</code>
            and <code>v-html</code> in Vue's template syntax.
        </p>
        <p>
            When the value of the target's observed property changes, we need to update the bound element's property or attribute.
            This means a triggering <code>'change'</code> event is needed that is then subscribed to.
            A framework's templating system will compare state across time, and detect the changed values automatically. 
            Lacking such a system we need a light-weight alternative.
        </p>
        <p>
            When the property being bound to is a signal, this code registers an effect on the signal.
            When the property is just a value, it registers an event listener on the target object,
            making it the responsibility of that target object to dispatch the <code>'change'</code> event when values change.
            This approach isn't going to get many points for style, but it does work.
        </p>
        <p>
            Check out the <a href="example-combined/bind.js">completed bind.js</a> code.
        </p>

        <h3>Bringing the band together</h3>

        <p>
            In the article <a href="https://dev.to/richharris/why-i-don-t-use-web-components-2cia">Why I don't use web components</a> 
            Svelte's Rich Harris lays out the case against web components. He demonstrates how this simple 9 line Svelte component
            <code>&lt;Adder a={1} b={2}/&gt;</code> becomes an incredible verbose 59 line monstrosity when ported to a vanilla web component.
        </p>
        <div><pre><code>&lt;script&gt;
  export let a;
  export let b;
&lt;/script&gt;

&lt;input type="number" bind:value={a}&gt;
&lt;input type="number" bind:value={b}&gt;

&lt;p&gt;{a} + {b} = {a + b}&lt;/p&gt;</code></pre></div>

        <p>
            Now that we have assembled our three helper functions <code>html()</code>, <code>signal()</code> and <code>bind()</code>
            on top of the web components baseline, at a total budget of around 150 lines of code, how close can we get for a web component <code>&lt;x-adder a="1" b="2"&gt;&lt;/x-adder&gt;</code>?
        </p>
        <div><pre><code>import { bind } from './bind.js';
import { signal, computed } from './signals.js';
import { html } from './html.js';

customElements.define('x-adder', class Adder extends HTMLElement {
    a = signal();
    b = signal();
    result = computed(() =&gt; 
        html`${+this.a} + ${+this.b} = ${+this.a + +this.b}`, [this.a, this.b]);

    connectedCallback() {
        this.a.value ??= this.getAttribute('a') || 0;
        this.b.value ??= this.getAttribute('b') || 0;
        this.append(bind(html`
            &lt;input type="number" :value="a" @input="a" /&gt;
            &lt;input type="number" :value="b" @input="b" /&gt;
            &lt;p :html="result"&gt;&lt;/p&gt;
        `, this));
    }
});
</code></pre></div>
        <p><a href="https://plainvanillaweb.com/blog/articles/2024-09-03-unix-philosophy/example-combined/example.html">combined example</a></p>

        <p>
            To be fair, that's still twice the lines of code, but it describes clearly what it does, and really that is all you need. 
            And I'm just shooting in the wind here, trying stuff out.
            Somewhere out there could be a minimal set of functions that transforms web components into something resembling a framework,
            and the idea excites me! Who knows, maybe in a few years the web community will return to writing projects in 
            vanilla web code, dragging along the modern equivalent of <code>utilities.js</code> from project to project...
        </p>
        <br>
        <p><em>What do you think?</em></p>
    ]]></content>
    </entry>
    <entry>
        <title><![CDATA[Poor man's signals]]></title>
        <link rel="alternate" type="text/html" href="https://plainvanillaweb.com/blog/articles/2024-08-30-poor-mans-signals/"/>
        <id>https://plainvanillaweb.com/blog/articles/2024-08-30-poor-mans-signals/</id>
        <published>2024-08-30T12:00:00.000Z</published>
        <updated>2024-08-30T12:00:00.000Z</updated>
        <summary><![CDATA[Signals are all the rage over in frameworkland, so let's bring them to vanilla JS.]]></summary>
        <media:content url="https://plainvanillaweb.com/blog/articles/2024-08-30-poor-mans-signals/image.webp" type="image/webp" medium="image" />
        <author><name><![CDATA[Joeri Sebrechts]]></name></author>
        <content type="html"><![CDATA[
        <p>
            Signals are all the rage right now. Everyone's doing them.
            <a href="https://angular.dev/guide/signals">Angular</a>,
            and <a href="https://docs.solidjs.com/concepts/signals">Solid</a>,
            and <a href="https://preactjs.com/guide/v10/signals/">Preact</a>,
            and there are third party packages for just about every framework that doesn't already have them.
            There's even a <a href="https://github.com/tc39/proposal-signals">proposal</a>
            to add them to the language, and if that passes it's just a 
            <a href="https://thenewstack.io/did-signals-just-land-in-react/">matter of time</a> before all frameworks 
            have them built in.
        </p>

        <h3>Living under a rock</h3>
        <p>
            In case you've been living under a rock, here's the example from Preact's documentation 
            that neatly summarizes what signals do:
        </p>
        <div><pre><code>import { signal, computed, effect } from "@preact/signals";

const name = signal("Jane");
const surname = signal("Doe");
const fullName = computed(() =&gt; `${name.value} ${surname.value}`);

// Logs name every time it changes:
effect(() =&gt; console.log(fullName.value));
// Logs: "Jane Doe"

// Updating `name` updates `fullName`, which triggers the effect again:
name.value = "John";
// Logs: "John Doe"
</code></pre></div>
        <p>
            Simply put, signals wrap values and computations 
            in a way that allows us to easily respond to every change to those values and results in a targeted way,
            without having to rerender the entire application in the way that we would do in React.
            In short, signals are an efficient and targeted way to respond to changes without having to do state comparison and DOM-diffing.
        </p>
        <p>
            OK, so, if signals are so great, why am I trying to sell you on them on a vanilla web development blog?
            Don't worry! Vanilla web developers can have signals too.
        </p>

        <h3>Just a wrapper</h3>
        <p>
            Signals are at heart nothing more than a wrapper for a value that sends events when the value changes.
            That's nothing that a little trickery with the not well known but very handy <code>EventTarget</code> base class can't fix for us.
        </p>
        <div><pre><code>class Signal extends EventTarget {
    #value;
    get value () { return this.#value; }
    set value (value) {
        if (this.#value === value) return;
        this.#value = value;
        this.dispatchEvent(new CustomEvent('change')); 
    }

    constructor (value) {
        super();
        this.#value = value;
    }
}</code></pre></div>
        <p>
            This gets us a very barebones signals experience:
        </p>
        <div><pre><code>const name = new Signal('Jane');
name.addEventListener('change', () =&gt; console.log(name.value));
name.value = 'John';
// Logs: John</code></pre></div>
        <p>
            But that's kind of ugly. The <code>new</code> keyword went out of fashion a decade ago,
            and that <code>addEventListener</code> sure is unwieldy.
            So let's add a little syntactic sugar.
        </p>
        <div><pre><code>class Signal extends EventTarget {
    #value;
    get value () { return this.#value; }
    set value (value) {
        if (this.#value === value) return;
        this.#value = value;
        this.dispatchEvent(new CustomEvent('change')); 
    }

    constructor (value) {
        super();
        this.#value = value;
    }

    effect(fn) {
        fn();
        this.addEventListener('change', fn);
        return () =&gt; this.removeEventListener('change', fn);
    }

    valueOf () { return this.#value; }
    toString () { return String(this.#value); }
}

const signal = _ =&gt; new Signal(_);
</code></pre></div>
        <p>
            Now our barebones example is a lot nicer to use:
        </p>
        <div><pre><code>const name = signal('Jane');
name.effect(() =&gt; console.log(name.value));
// Logs: Jane
name.value = 'John';
// Logs: John</code></pre></div>
        <p>
            The <code>effect(fn)</code> method will call the specified function,
            and also subscribe it to changes in the signal's value.
        </p>
        <p>
            It also returns a dispose function that can be used to unregister the effect.
            However, a nice side effect of using <code>EventTarget</code> and browser built-in events as the reactivity primitive
            is that it makes the browser smart enough to garbage collect the signal and its effect when the signal goes out of scope.
            This means less chance for memory leaks even if we never call the dispose function.
        </p>
        <p>
            Finally, the <code>toString</code> and <code>valueOf</code> magic methods allow for dropping <code>.value</code> in most places
            that the signal's value gets used. (But not in this example, because the console is far too clever for that.)
        </p>

        <h3>Does not compute</h3>
        <p>
            This signals implementation is already capable, but at some point it might be handy to have an effect based on more than one signal.
            That means supporting computed values. Where the base signals are a wrapper around a value,
            computed signals are a wrapper around a function.
        </p>
        <div><pre><code>class Computed extends Signal {
    constructor (fn, deps) {
        super(fn(...deps));
        for (const dep of deps) {
            if (dep instanceof Signal) 
                dep.addEventListener('change', () =&gt; this.value = fn(...deps));
        }
    }
}

const computed = (fn, deps) =&gt; new Computed(fn, deps);
</code></pre></div>
        <p>
            The computed signal calculates its value from a function.
            It also depends on other signals, and when they change it will recompute its value.
            It's a bit obnoxious to have to pass the signals that it depends on
            as an additional parameter, but hey, I didn't title this article <em>Rich man's signals</em>.
        </p>
        <p>
            This enables porting Preact's signals example to vanilla JS.
        </p>
        <div><pre><code>const name = signal('Jane');
const surname = signal('Doe');
const fullName = computed(() =&gt; `${name} ${surname}`, [name, surname]);
// Logs name every time it changes:
fullName.effect(() =&gt; console.log(fullName.value));
// -&gt; Jane Doe

// Updating `name` updates `fullName`, which triggers the effect again:
name.value = 'John';
// -&gt; John Doe
</code></pre></div>

        <h3>Can you use it in a sentence?</h3>
        <p>
            You may be thinking, all these <code>console.log</code> examples are fine and dandy,
            but how do you use this stuff in actual web development?
            This simple adder demonstrates how signals can be combined with web components:
        </p>
        <div><pre><code>import { signal, computed } from './signals.js';

customElements.define('x-adder', class extends HTMLElement {
    a = signal(1);
    b = signal(2);
    result = computed((a, b) =&gt; `${a} + ${b} = ${+a + +b}`, [this.a, this.b]);

    connectedCallback() {
        if (this.querySelector('input')) return;

        this.innerHTML = `
            &lt;input type="number" name="a" value="${this.a}"&gt;
            &lt;input type="number" name="b" value="${this.b}"&gt;
            &lt;p&gt;&lt;/p&gt;
        `;
        this.result.effect(
            () =&gt; this.querySelector('p').textContent = this.result);
        this.addEventListener('input', 
            e =&gt; this[e.target.name].value = e.target.value);
    }
});
</code></pre></div>
        <p>
            And here's a live demo:
        </p>
        <p><a href="https://plainvanillaweb.com/blog/articles/2024-08-30-poor-mans-signals/adder.html">adder.html</a></p>
        <p>
            In case you were wondering, the <code>if</code> is there to prevent adding the effect twice
            if connectedCallback is called when the component is already rendered.
        </p>
        <p>
            The full poor man's signals code in all its 36 line glory can be found in the <a href="https://github.com/jsebrech/tiny-signals/">tiny-signals repo</a> on Github.
        </p>
    ]]></content>
    </entry>
    <entry>
        <title><![CDATA[Vanilla entity encoding]]></title>
        <link rel="alternate" type="text/html" href="https://plainvanillaweb.com/blog/articles/2024-08-25-vanilla-entity-encoding/"/>
        <id>https://plainvanillaweb.com/blog/articles/2024-08-25-vanilla-entity-encoding/</id>
        <published>2024-08-25T12:00:00.000Z</published>
        <updated>2024-08-25T12:00:00.000Z</updated>
        <summary><![CDATA[The first version of this site didn't use entity encoding in the examples. Now it does.]]></summary>
        <media:content url="https://plainvanillaweb.com/blog/articles/2024-08-25-vanilla-entity-encoding/image.webp" type="image/webp" medium="image" />
        <author><name><![CDATA[Joeri Sebrechts]]></name></author>
        <content type="html"><![CDATA[
        <h3>Good enough</h3>
        <p>
            When I made the first version of the Plain Vanilla website, there were things that I would have liked
            to spend more time on, but that I felt didn't belong in a Good Enough™ version of the site.
            One of those things was defending against <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html">Cross-Site Scripting</a> (XSS).
        </p>
        <p>
            XSS is still in the <a href="https://owasp.org/www-project-top-ten/">OWASP Top Ten</a> of security issues, 
            but it's no longer as prevalent as it used to be. Frameworks have built in a lot of defenses, 
            and when using their templating systems you have to go out of your way to inject code into the generated HTML.
            When eschewing frameworks we're reduced to standard templating in our web components, and those offer no defense against XSS.
        </p>
        <p>
            Because of this, in the original site the <a href="https://plainvanillaweb.com/pages/components.html#passing-data">Passing Data example</a> 
            on the <em>Components</em> page had an undocumented XSS bug.
            The <em>name</em> field could have scripts injected into it. I felt ambivalent about leaving that bug in.
            On the one hand, the code was very compact and neat by leaving it in.
            On the other hand it made that code a bad example that shouldn't be copied.
            I ended up choosing to leave it as-is because an example doesn't have to be production-grade
            and generating properly encoded HTML was not the point of that specific example.
            It's time however to circle back to that XSS bug and figure out how it would have been solved in a clean and readable way,
            if Santa really did want to bring his List application to production-level quality.
        </p>

        <h3>The problem</h3>
        <p>
            The basic problem we need to solve is that vanilla web components end up having a lot of code that looks like this:
        </p>
        <div><pre><code>class MyComponent extends HTMLElement {
    connectedCallback() {
        const btn = `&lt;button&gt;${this.getAttribute('foo')}&lt;/button&gt;`;
        this.innerHTML = `
            &lt;header&gt;&lt;h1&gt;${this.getAttribute('bar')}&lt;/h1&gt;&lt;/header&gt;
            &lt;article&gt;
                &lt;p class="${this.getAttribute('baz')}"&gt;${this.getAttribute('xyzzy')}&lt;/p&gt;
                ${btn}
            &lt;/article&gt;
        `;
    }
}
customElements.define('my-component', MyComponent);</code></pre></div>
        <p>
            If any of <code>foo</code>, <code>bar</code>, <code>baz</code> or <code>xyzzy</code> contain one of the dangerous HTML entities,
            we risk seeing our component break, and worst-case risk seeing an attacker inject a malicious payload into the page.
            Just as a reminder, those dangerous HTML entities are &lt;, &gt;, &amp;, ' and ".
        </p>

        <h3>The fix, take one</h3>
        <p>
            A naive fix is creating a html-encoding function and using it consistently:
        </p>
        <div><pre><code>function htmlEncode(s) {
    return s.replace(/[&amp;&lt;&gt;'"]/g,
        tag =&gt; ({
            '&amp;': '&amp;amp;',
            '&lt;': '&amp;lt;',
            '&gt;': '&amp;gt;',
            "'": '&amp;#39;',
            '"': '&amp;quot;'
        }[tag]))
}

class MyComponent extends HTMLElement {
    connectedCallback() {
        const btn = `&lt;button&gt;${htmlEncode(this.getAttribute('foo'))}&lt;/button&gt;`;
        this.innerHTML = `
            &lt;header&gt;&lt;h1&gt;${htmlEncode(this.getAttribute('bar'))}&lt;/h1&gt;&lt;/header&gt;
            &lt;article&gt;
                &lt;p class="${htmlEncode(this.getAttribute('baz'))}"&gt;${htmlEncode(this.getAttribute('xyzzy'))}&lt;/p&gt;
                ${btn}
            &lt;/article&gt;
        `;
    }
}
customElements.define('my-component', MyComponent);</code></pre></div>
        <p>
            While this does work to defend against XSS, it is verbose and ugly, not pleasant to type and not pleasant to read.
            What really kills it though, is that it assumes attention to detail from us messy humans. We can never forget,
            never ever, to put a <code>htmlEncode()</code> around each and every variable.
            In the real world, that is somewhat unlikely.
        </p>
        <p>
            What is needed is a solution that allows us to forget about entity encoding, by doing it automatically
            when we're templating. I drew inspiration from templating libraries that work in-browser and are based on tagged templates, 
            like <a href="https://lit.dev/docs/api/templates/#html">lit-html</a> 
            and <a href="https://github.com/developit/htm">htm</a>. The quest was on to build the most minimalistic
            html templating function that encoded entities automatically.
        </p>

        <h3>The fix, take two</h3>
        <p>
            Ideally, the fixed example should look more like this:
        </p>
        <div><pre><code>import { html } from './html.js';

class MyComponent extends HTMLElement {
    connectedCallback() {
        const btn = html`&lt;button&gt;${this.getAttribute('foo')}&lt;/button&gt;`;
        this.innerHTML = html`
            &lt;header&gt;&lt;h1&gt;${this.getAttribute('bar')}&lt;/h1&gt;&lt;/header&gt;
            &lt;article&gt;
                &lt;p class="${this.getAttribute('baz')}"&gt;${this.getAttribute('xyzzy')}&lt;/p&gt;
                ${btn}
            &lt;/article&gt;
        `;
    }
}
customElements.define('my-component', MyComponent);</code></pre></div>
        <p>
            The <code>html``</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates">tagged template function</a> 
            would automatically encode entities, in a way that we don't even have to think about it.
            Even when we nest generated HTML inside of another template, like with <code>${btn}</code>, it should just magically work.
            It would be so minimal as to disappear in the background, barely impacting readability, maybe even improving it.
            You may be thinking that doing that correctly would involve an impressive amount of code. I must disappoint.
        </p>
        <div><pre><code>class Html extends String { }

/** 
 * tag a string as html not to be encoded
 * @param {string} str
 * @returns {string}
 */
export const htmlRaw = str =&gt; new Html(str);

/** 
 * entity encode a string as html
 * @param {*} value The value to encode
 * @returns {string}
 */
export const htmlEncode = (value) =&gt; {
    // avoid double-encoding the same string
    if (value instanceof Html) {
        return value;
    } else {
        // https://stackoverflow.com/a/57448862/20980
        return htmlRaw(
            String(value).replace(/[&amp;&lt;&gt;'"]/g, 
                tag =&gt; ({
                    '&amp;': '&amp;amp;',
                    '&lt;': '&amp;lt;',
                    '&gt;': '&amp;gt;',
                    "'": '&amp;#39;',
                    '"': '&amp;quot;'
                }[tag]))
        );
    }
}

/** 
 * html tagged template literal, auto-encodes entities
 */
export const html = (strings, ...values) =&gt; 
    htmlRaw(String.raw({ raw: strings }, ...values.map(htmlEncode)));
</code></pre></div>
        <p>
            Those couple dozen lines of code are all that is needed. Let's go through it from top to bottom.
        </p>
        <dl>
            <dt><code>class Html extends String { }</code></dt>
            <dd>The Html class is used to mark strings as encoded, so that they won't be encoded again.</dd>
            <dt><code>export const htmlRaw = str =&gt; new Html(str);</code></dt>
            <dd>Case in point, the htmlRaw function does the marking.</dd>
            <dt><code>export const htmlEncode = ...</code></dt>
            <dd>The earlier htmlEncode function is still doing useful work, only this time it will mark the resulting string as HTML, and it won't double-encode.</dd>
            <dt><code>export const html = ...</code></dt>
            <dd>The tagged template function that binds it together.</dd>
        </dl>

        <p>
            A nice upside of the html template function is that the <em>html-in-template-string</em> Visual Studio Code extension
            can detect it automatically and will syntax highlight the templated HTML. This is what example 3 looked like after I made it:
        </p>

        <img src="https://plainvanillaweb.com/blog/articles/2024-08-25-vanilla-entity-encoding/syntax-highlighting.webp" alt="example 3 with syntax highlighting">

        <p>
            Granted, there's still a bunch of boilerplate here, and that <code>getAttribute</code> gets unwieldy.
            But with this syntax highlighting enabled sometimes when I'm working on vanilla web components I forget it's not React and JSX, but just HTML and JS.
            It's surprising how nice of a development experience web standards can be if you embrace them.
        </p>

        <p>
            I decided to leave the XSS bug in the <em>Passing Data</em> example, but now the <em>Applications</em> page
            has an explanation about entity encoding documenting this html template function.
            I can only hope people that work their way through the tutorial make it that far.
            For your convenience I also put the HTML templating function in its own separate 
            <a href="https://github.com/jsebrech/html-literal">html-literal repo on Github</a>.
        </p>

    ]]></content>
    </entry>
    <entry>
        <title><![CDATA[Let's build a blog, vanilla-style!]]></title>
        <link rel="alternate" type="text/html" href="https://plainvanillaweb.com/blog/articles/2024-08-17-lets-build-a-blog/"/>
        <id>https://plainvanillaweb.com/blog/articles/2024-08-17-lets-build-a-blog/</id>
        <published>2024-08-17T12:00:00.000Z</published>
        <updated>2024-08-26T12:00:00.000Z</updated>
        <summary><![CDATA[Explaining how this vanilla web development blog was built, using nothing but vanilla web techniques.]]></summary>
        <media:content url="https://plainvanillaweb.com/blog/articles/2024-08-17-lets-build-a-blog/image.webp" type="image/webp" medium="image" />
        <author><name><![CDATA[Joeri Sebrechts]]></name></author>
        <content type="html"><![CDATA[
        <p>
            As I write this paragraph it is my birthday, and it seemed like as good an opportunity as any to start a blog about vanilla web development.
            This blog post will be a bit unusual, as I will be writing it while I'm making the blog's inner workings.
            But before I get around to figuring out and then explaining how it was made, let me start with why.
        </p>

        <section>
            <h3>Origin story</h3>
            <p>
                I have been building web sites since the late 90's, and over the years there were always two constants:
                (1) browsers were terrible developer platforms, (2) new tools and frameworks built ever taller on top of them.
                The tools were necessary, but their growing complexity frustrated me, and in that frustration lies the origin of this blog.
            </p>
            <p>
                A few years ago something unexpected happened: Microsoft moved away from their (underfeatured) Trident browser engine.
                Suddenly there was a new baseline of browsers, a capable baseline. Browsers got good!
                I explored what modern browsers could do as a developer platform, and grew excited with the possibilities
                to treat the browser itself as the framework, without a middleman. 
                That eventually led into making the <a href="https://plainvanillaweb.com">Plain Vanilla website</a>, a framework tutorial for the web standards platform.
            </p>
            <p>
                In building this website editorial choices had to be made.
                Trying to explain too much would only confuse people, so the tutorial was trimmed of its fat.
                There is however so much more to explore, and that is where this blog enters the picture.
                Here I will talk about some of the things that didn't find a home in the Plain Vanilla tutorial,
                and document the new things that do.
            </p> 
        </section>

        <section>
            <h3>What is a blog anyway?</h3>

            <p>
                Of course, a blog about vanilla web development has to be built vanilla-style.
                That means no build steps, no server-side logic, no frameworks or libraries.
                Bottom line that means throwing up a bunch of HTML pages with an index page linking them together,
                but that by itself isn't enough. The idea is to make a full-fat modern feeling blog,
                something that has what people expect a blog to have. So off I went to look at popular blogs and build a list of features.
            </p>
            <p>A <em>modern</em> blog will have ...</p> 
            <ul>
                <li>One page per article, easy for sharing as a link and discovery by Google.</li>
                <li>A welcome page, with one or more hero cards leading to articles and a list of cards for recent articles.</li>
                <li>An archive page, with the full history of articles linking to the article pages.</li>
                <li>An RSS feed, for the 20 most recent articles, containing the full text.</li>
                <li>Comments on every article. This is a big one.</li>
                <li>Some colors and imagery, to spruce things up and please the readers.</li>
                <li>Easy to author articles. This is also a big one.</li>
            </ul>
            <p>The challenge was: how to do all of that within the vanilla constraints that I set myself?</p>
        </section>

        <section>
            <h3>Article-first design</h3>

            <p>
                The core of the blog experience is the article, so getting that right is key and that makes it the best place to start.
                Lacking any kind of generator or server-side routing, each article has to be written as a discrete html page
                in order to be discoverable by Google. Authoring those html pages should be straightforward,
                with minimal boilerplate.
            </p>

            <p>After careful consideration we present to you, an article page blueprint...</p>
            <div><pre><code>&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;title&gt;A spiffy title!&lt;/title&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" /&gt;
    &lt;meta name="description" content="This is a spiffy article. You should read it."&gt;
    &lt;link rel="stylesheet" href="index.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;blog-header published="2024-08-17"&gt;
        &lt;img src="image.jpeg" alt="Another AI image" loading="lazy" /&gt;
        &lt;h2&gt;A spiffy title!&lt;/h2&gt;
        &lt;p class="byline" aria-label="author"&gt;Malkovich&lt;/p&gt;
    &lt;/blog-header&gt;
    &lt;main&gt;
        Article text goes here ...
    &lt;/main&gt;
    &lt;blog-footer mastodon-url="https://example.com/@jmalkovich/12345"&gt;&lt;/blog-footer&gt;
    &lt;script type="module" src="index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></div>

            <p>
                This does several things for me. It keeps the &lt;head&gt; section as minimal as possible.
                It also moves the navigation at the top and bottom into dedicated web components.
                The header component accepts the article's image and title as child elements,
                neatly leaving the main element containing just the article's content and nothing else,
                making it easy to extract (but more on that later).
            </p>
            <p>
                When users have scripting disabled they won't get the header navigation, 
                but thanks to this CSS they do get a warning:<br>
                <code>@media (scripting: none) { blog-header::before { content: ' ... ' } }</code><br>
                This approach frees me from thinking about noscript warnings while writing an article.
            </p>
            <p>
                Finally, for comments I considered Disqus, but didn't want to include their embed.
                So instead the footer accepts the URL to a mastodon toot about the article,
                and will automatically generate a link that goes there. Given that the blog has a technical audience
                I'm pretty sure they can figure out how to reply over there. This approach can be extended
                to <a href="https://carlschwan.eu/2020/12/29/adding-comments-to-your-static-blog-with-mastodon/">show replies inline on the page</a>
                by calling the Mastodon API, but I didn't tackle that yet. It's somewhat cumbersome to first post an article, 
                then toot about it, and then update the article with the toot's URL, but I'll survive.
                Incidentally, I still giggle like a schoolgirl inside my head every time I type the word <em>toot</em>.
            </p>
        </section>

        <section>
            <h3>Organizing files</h3>

            <p>
                Next comes the question how to organize the article files into a coherent structure.
                After thinking it over, this is what I landed on:
            </p>
            <ul>
                <li><code>articles/</code>
                    <ul>
                        <li><code><em>YYYY-MM-DD</em>-some-blog-title/</code>
                            <ul>
                                <li><code>index.html</code></li>
                                <li><code>image.jpeg</code></li>
                                <li>other files used in the article ...</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><code>components/</code>: the blog's shared web components</li>
                <li><code>index.html</code>: the main landing page</li>
                <li><code>archive.html</code>: the archives page</li>
                <li><code>index.js/css</code>: shared resources</li>
                <li><code>feed.xml</code>: the RSS feed</li>
            </ul>
            <p>
                By wrapping every article and all its resources into a folder, each article can get as messy and complicated as it wants.
                The shared index.js and index.css is separate from that of the main site
                to keep the blog's resources out of the Plain Vanilla site's pages, and vice versa.
            </p>
        </section>

        <section>
            <h3>Building indexes</h3>

            <p>
                You wouldn't think a blog has a need for many indexes, but in fact this modest blog will have three:
            </p>
            <ol>
                <li>The recent posts section on the main landing page</li>
                <li>The recent posts in the RSS feed</li>
                <li>The full list of articles in the archive page</li>
            </ol>
            <p>
                Visually showing an index is not so difficult, as a web component built around a simple <code>&lt;li&gt;</code>-based
                card design can be used to show both the recent posts and the archive page, and was straighforward to style with CSS.
            </p>
            <div><pre><code>&lt;ul class="cards"&gt;
    &lt;li class="card"&gt;
        &lt;img src="./articles/2024-08-17-lets-build-a-blog/image.webp" aria-hidden="true" loading="lazy" /&gt;
        &lt;h3&gt;&lt;a href="./articles/2024-08-17-lets-build-a-blog/"&gt;Let's build a blog, vanilla-style!&lt;/a&gt;&lt;/h3&gt;
        &lt;p&gt;Explaining how this vanilla web development blog was built, using nothing but vanilla web techniques.&lt;/p&gt;
        &lt;small&gt;
            &lt;time datetime="2024-08-17"&gt;August 17, 2024&lt;/time&gt;
        &lt;/small&gt;
    &lt;/li&gt;
&lt;/ul&gt;</code></pre></div>
            <p>
                Getting that data in a convenient form however is another matter.
                The RSS feed contains full text contents, so needs a separate step to build from the articles' HTML.
                The recent posts section on the index page thankfully can be built by reading the RSS feed,
                so was trivial to solve with a <code>&lt;blog-latest-posts&gt;</code> web component once the feed was set up.
                The full list of articles however cannot, as the RSS feed would grow too large if it contained all posts.
                So the archive page needs another separate step to build the full list of links from the folder of articles.
            </p>
            <p>
                For these build steps I considered various options:
            </p>
            <dl>
                <dt>❌ <del>Manually keeping the files in sync</del></dt><dt>
                </dt><dd>
                    It sounded like a lot of work, and error-prone, so a hard no on that one.
                </dd>
                <dt>❌ <del>A generator script, and a package.json</del></dt>
                <dd>
                    This is what I would normally go for, relying on a bunch of npm dependencies and a bunch of scripting
                    to process the articles into the index files that are needed. 
                    It felt like cheating to bring in node and its ecosystem, so again this was a no.
                </dd>
                <dt>✅ A separate generator webpage</dt>
                <dd>
                    I've wanted to play around with the
                    <a href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_API">File System API</a>
                    for a while, and this seemed a good opportunity.
                    Turning the generator into a webpage also leaves options for actually running the web components
                    and extracting their dynamically rendered content.
                </dd>
            </dl>

            <p>
                For the generator page I built a dedicated web component that allows opening or dropping the
                local <code>blog/</code> folder with the newly written or updated articles,
                and then will process those into a <code>feed.xml</code> and <code>index.json</code>.
                The JSON file is used to load the contents of the archive page.
                The RSS feed is particularly tricky, because there is a limited set of tags that it should contain.
                By loading the article's HTML into a DOM parser, and replacing all unsupported tags (like the code viewer web component shown below)
                the HTML can be transformed into something that can be used as RSS feed entry contents.
            </p>
            <p>The core logic of the generator extracts the article's metadata and transforms the HTML:</p>
            <div><pre><code>customElements.define('blog-generator', class BlogGenerator extends HTMLElement {

    // ...

    async processArticle(article, path) {
        const file = await article.getFile();
        const html = await file.text();
        const dom = (new DOMParser()).parseFromString(html, 'text/html');
        // mandatory
        const title = dom.querySelector('title').textContent;
        const summary = dom.querySelector('meta[name="description"]').getAttribute('content');
        const published = dom.querySelector('blog-header').getAttribute('published');
        const content = await this.processArticleContent(dom.querySelector('main'), path);
        const slug = path.name;
        // optional
        const img = dom.querySelector('blog-header img');
        const image = img &amp;&amp; { src: img.getAttribute('src'), alt: img.getAttribute('alt') };
        const updated = dom.querySelector('blog-header').getAttribute('updated') || undefined;

        this.#articles.push({
            slug, title, summary, content, published, updated, image
        });
    }

    async processArticleContent(main, path) {
        // inline code examples
        await Promise.all([...main.querySelectorAll('x-code-viewer')].map(async (elem) =&gt; {
            const text = await this.downloadFile(elem.getAttribute('src'), path);
            const pre = document.createElement('pre');
            pre.innerHTML = html`&lt;code&gt;${text}&lt;/code&gt;`;
            elem.replaceWith(pre);
        }));

        // convert img src to absolute url
        [...main.querySelectorAll('img')].map((elem) =&gt; {
            const src = elem.getAttribute('src');
            if (src.indexOf('http') !== 0) {
                elem.setAttribute('src', new URL(`articles/${path.name}/${src}`, BLOG_BASE_URL));
            }
        });

        // replace iframes by links
        [...main.querySelectorAll('iframe')].map((elem) =&gt; {
            const src = elem.getAttribute('src');
            const title = elem.getAttribute('title') || src;
            const a = document.createElement('a');
            a.textContent = title;
            const p = document.createElement('p');
            p.appendChild(a);
            elem.replaceWith(p);
            if (src.indexOf('http') !== 0) {
                a.href = new URL(`articles/${path.name}/${src}`, BLOG_BASE_URL);
            } else {
                a.href = src;
            }
        });

        return main.innerHTML;
    }

    // ...

});</code></pre></div>

            <p>To give you an idea of what <a href="../../generator.html">generator.html</a> looks like in use:</p>
            <img src="https://plainvanillaweb.com/blog/articles/2024-08-17-lets-build-a-blog/generator.webp" alt="generator page screenshot">

            <p>
                The generator JS ended up around 250 lines of code, so not too cumbersome to build or maintain.
                If you're curious about the generator, check out the 
                <a href="https://github.com/jsebrech/plainvanilla/tree/main/public/blog/">blog's code on Github</a>.
                It can be found in <code>generator.html</code> and <code>generator.js</code>.
            </p>

            <p>The user experience of writing a blog post then boils down to this:</p>
            <ol>
                <li>Create an article folder and write the article as HTML</li>
                <li>Open the generator page</li>
                <li>Drop the blog folder on the generator, it will automatically process the articles</li>
                <li>Copy the <code>feed.xml</code> and <code>index.json</code> text to their respective files</li>
                <li>Commit and push the changes</li>
                <li>Optionally: toot on mastodon, add the toot URL in the page, commit and push</li>
            </ol>

            <p>Not too shabby...</p>
        </section>
    ]]></content>
    </entry>
</feed>