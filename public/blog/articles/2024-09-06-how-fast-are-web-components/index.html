<!doctype html>
<html lang="en">
<head>
    <title>How fast are web components?</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
    <meta name="description" content="Benchmarking the relative performance of different web component techniques.">
    <link rel="stylesheet" href="../../index.css">
    <style>
        table th:nth-of-type(1) {
            text-align: left;
            padding-right: 1em;
        }
        table td:nth-of-type(2) {
            text-align: right;
        }
    </style>
</head>
<body>
    <blog-header published="2024-09-06">
        <img src="image.webp" alt="A snail and a hare in a race" loading="lazy" />
        <h2>How fast are web components?</h2>
        <p class="byline" aria-label="author">Joeri Sebrechts</p>
    </blog-header>
    <main>
        <p>
            It is often said that web components are slow.
            This was also my experience when I first tried building web components a few years ago.
            At the time I was using the Stencil framework, because I didn't feel confident that they could be built well without a framework.
            Performance when putting hundreds of them on a page was so bad that I ended up going back to React.
        </p>
        <p>
            But as I've gotten deeper into vanilla web development I started to realize that maybe I was just using it wrong.
            Perhaps web components can be fast, if built in a light-weight way.
            This article is an attempt to settle the question "How fast are web components?".
        </p>

        <h3>The lay of the land</h3>

        <p>
            What kinds of questions did I want answered?
        </p>
        <ul>
            <li>How many web components can you render on the page in a millisecond?</li>
            <li>Does the technique used to built the web component matter, which technique is fastest?</li>
            <li>How do web component frameworks compare? I used Lit as the framework of choice as it is well-respected.</li>
            <li>How does React compare?</li>
            <li>What happens when you combine React with web components?</li>
        </ul>

        <p>
            To figure out the answer I made a benchmark as a vanilla web page (of course),
            that rendered 100.000 very simple components containing only <code>&lt;span&gt;.&lt;/span&gt;</code>
            and measured the elapsed time. This benchmark was then run on multiple devices and multiple browsers
            to figure out performance characteristics. The ultimate goal of this test is to figure out the absolute best performance
            that can be extracted from the most minimal web component.
        </p>

        <p>To get a performance range I used two devices for testing:</p>
        <ul>
            <li>A <em>Macbook Air M1</em> running MacOS, to stand in as the "fast" device, comparable to a new high end iPhone.</li>
            <li>An <em>Asus Chi T300 Core M</em> from 2015 running Linux Mint Cinnamon, to stand in as the "slow" device, comparable to an older low end Android.</li>
        </ul>
        <p>Between these devices is a 7x CPU performance gap.</p>

        <h3>The test</h3>

        <p>
            The test is simple: render 100.000 components using a specific technique, 
            call <code>requestAnimationFrame()</code> to make sure they actually render,
            then measure elapsed time. This produces a <em>components per millisecond</em> number.
        </p>
        <p>The techniques being compared:</p>
        <ul>
            <li><strong>innerHTML:</strong> each web component renders its content by assigning to <code>this.innerHTML</code></li>
            <li><strong>append:</strong> each web component creates the span using <code>document.createElement</code> and then appends it to itself</li>
            <li><strong>append (buffered):</strong> same as the append method, except all web components are first buffered to a document fragment which is then appended to the DOM</li>
            <li><strong>shadow + innerHTML:</strong> the same as innerHTML, except each component has a shadow DOM</li>
            <li><strong>shadow + append:</strong> the same as append, except each component has a shadow DOM</li>
            <li><strong>lit:</strong> each web component is rendered using the lit framework, in the way that its documentation recommends</li>
            <li><strong>template + append:</strong> each web component renders its content by cloning a template and appending it</li>
            <li><strong>react pure:</strong> rendering in React using a standard React component</li>
            <li><strong>react + wc:</strong> each React component wraps the append-style web component</li>
        </ul>
        <p>
            This test was run on M1 in Brave, Chrome, Edge, Firefox and Safari. And on Chi in Chrome and Firefox.
            It was run once to warm up the browser, then repeated three times.
        </p>

        <h3>The results</h3>

        <p>First, let's compare techniques. The number here is components per millisecond, so <strong>higher is better</strong>.</p>
        
        <table>
            <thead>
                <tr><th colspan="2">Chrome on M1, best of three</th></tr>
                <tr><th>technique</th><th>components/ms</th></tr>
            </thead>
            <tbody>
                <tr><td>innerHTML</td><td>143</td></tr>
                <tr><td>append</td><td>233</td></tr>
                <tr><td>append (buffered)</td><td>228</td></tr>
                <tr><td>shadow + innerHTML</td><td>132</td></tr>
                <tr><td>shadow + append</td><td>183</td></tr>
                <tr><td>lit</td><td>133</td></tr>
                <tr><td>template + append</td><td>181</td></tr>
                <tr><td>react pure</td><td>275</td></tr>
                <tr><td>react + wc</td><td>172</td></tr>
            </tbody>
        </table>

        <table>
            <thead>
                <tr><th colspan="2">Chrome on Chi, best of three</th></tr>
                <tr><th>technique</th><th>components/ms</th></tr>
            </thead>
            <tbody>
                <tr><td>innerHTML</td><td>25</td></tr>
                <tr><td>append</td><td>55</td></tr>
                <tr><td>append (buffered)</td><td>56</td></tr>
                <tr><td>shadow + innerHTML</td><td>24</td></tr>
                <tr><td>shadow + append</td><td>36</td></tr>
                <tr><td>lit</td><td>30</td></tr>
                <tr><td>template + append</td><td>45</td></tr>
                <tr><td>react pure</td><td>77</td></tr>
                <tr><td>react + wc</td><td>45</td></tr>
            </tbody>
        </table>

        <p>
            One relief right off the bat is that even the slowest implementation on the slow device
            renders 100.000 components in 4 seconds. React is faster than well-written web components, but never by more than 2x.
            That means for a typical web app performance is not a reason to avoid web components.
        </p>

        <p>
            As far as web component technique goes, the performance delta between the fastest and the slowest technique is around 2x,
            so again for a typical web app that difference will not matter. Things that slow down web components
            are shadow DOM and innerHTML. Appending cloned templates and avoiding shadow DOM is the right strategy
            for a well-performing web component.
        </p>

        <p>
            On the slow device the Lit framework is the worst performer, probably due to its use of shadow DOM and JS-heavy approaches.
            Meanwhile, pure React is the best performer, because while it does more work in creating the virtual DOM and diffing it to the real DOM,
            it benefits from not having to initialize the web component class instances.
            Consequently, when wrapping web components inside React components we see React's performance advantage disappear, and that it adds around a 20% performance tax.
        </p>

        <p>
            The fast device is up to 6x faster than the slow device in Chrome, depending on the technique used,
            so it is really worth testing applications on slow devices to get an idea of the range of performance.
        </p>

        <p>
            Next, let's compare browsers:
        </p>

        <table>
            <thead>
                <tr><th colspan="2">M1, append, best of three</th></tr>
                <tr><th>browser</th><th>components/ms</th></tr>
            </thead>
            <tbody>
                <tr><td>Brave</td><td>146</td></tr>
                <tr><td>Chrome</td><td>233</td></tr>
                <tr><td>Edge</td><td>224</td></tr>
                <tr><td>Firefox</td><td>232</td></tr>
                <tr><td>Safari</td><td>260</td></tr>
            </tbody>
        </table>

        <table>
            <thead>
                <tr><th colspan="2">Chi, append, best of three</th></tr>
                <tr><th>browser</th><th>components/ms</th></tr>
            </thead>
            <tbody>
                <tr><td>Chrome</td><td>55</td></tr>
                <tr><td>Firefox</td><td>180</td></tr>
            </tbody>
        </table>

        <p>
            Brave is really slow. Safari is pretty fast. Firefox is surprisingly decent,
            and actually a great performer on slow devices where it outshines Chrome by a lot.
            Using the "wrong" browser turns a fast machine into a slow machine (compare Brave on M1 to Firefox on Chi).
        </p>
        <p>
            There is a large performance gap when you compare the slowest technique on the slowest browser on the slowest device,
            with its fastest opposite combo. Specifically, there is a 13x performance gap:
        </p>
        <ul>
            <li>React pure, Safari on M1: 316 components/ms</li>
            <li>Shadow DOM + innerHTML, Chrome on Chi: 24 components/ms</li>
        </ul>
        <p>
            That means it becomes worthwhile to carefully consider technique when having to support a wide range of browsers and devices,
            because a bad combination may lead to a meaningfully degraded user experience.
        </p>
        
        <h3>Bottom line</h3>

        <p>
            I feel confident now that web components can be fast enough for almost all use cases where someone might consider React instead.
        </p>
        <p>
            However, it does matter how they are built. Shadow DOM should not be used for smaller often used web components,
            and the contents of those smaller components should be built using append operations instead of innerHTML.
            The use of web component frameworks might impact their performance significantly,
            and given how easy it is to write vanilla web components I personally don't see the point behind Lit or Stencil. YMMV.
        </p>

        <p>
            The full benchmark code and results can be <a href="https://github.com/jsebrech/vanilla-benchmarks">found on Github</a>.
        </p>

    </main>
    <blog-footer></blog-footer>
    <script type="module" src="../../index.js"></script>
</body>
</html>